{"version":3,"file":"index.module.js","sources":["../internal/rand.ts","../internal/util.ts","../internal/render/svg.ts","../internal/gen.ts","../public/legacy.ts"],"sourcesContent":["// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n","import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const coordPoint = (coord: Coord): Point => {\n    return {\n        ...coord,\n        handleIn: {angle: 0, length: 0},\n        handleOut: {angle: 0, length: 0},\n    };\n};\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n","import {Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nexport interface RenderOptions {\n    // Viewport size.\n    width: number;\n    height: number;\n\n    // Transformation applied to all drawn points.\n    transform?: string;\n\n    // Declare whether the path should be closed.\n    // This option is currently always true.\n    closed: true;\n\n    // Output path styling.\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n\n    // Option to render guides (points, handles and viewport).\n    guides?: boolean;\n    boundingBox?: boolean;\n}\n\nexport const renderPath = (points: Point[]): string => {\n    // Render path data attribute from points and handles.\n    let path = `M${points[0].x},${points[0].y}`;\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currControl = expandHandle(curr, curr.handleOut);\n        const nextControl = expandHandle(next, next.handleIn);\n        path += `C${currControl.x},${currControl.y},${nextControl.x},${nextControl.y},${next.x},${next.y}`;\n    });\n    return path;\n};\n\n// Renders the input points to an editable data structure which can be rendered to svg.\nexport const renderEditable = (points: Point[], options: RenderOptions): XmlElement => {\n    const stroke = options.stroke || (options.guides ? \"black\" : \"none\");\n    const strokeWidth = options.strokeWidth || (options.guides ? 1 : 0);\n\n    const xmlRoot = new XmlElement(\"svg\");\n    xmlRoot.attributes.width = options.width;\n    xmlRoot.attributes.height = options.height;\n    xmlRoot.attributes.viewBox = `0 0 ${options.width} ${options.height}`;\n    xmlRoot.attributes.xmlns = \"http://www.w3.org/2000/svg\";\n\n    const xmlContentGroup = new XmlElement(\"g\");\n    xmlContentGroup.attributes.transform = options.transform || \"\";\n\n    const xmlBlobPath = new XmlElement(\"path\");\n    xmlBlobPath.attributes.stroke = stroke;\n    xmlBlobPath.attributes[\"stroke-width\"] = strokeWidth;\n    xmlBlobPath.attributes.fill = options.fill || \"none\";\n    xmlBlobPath.attributes.d = renderPath(points);\n\n    xmlContentGroup.children.push(xmlBlobPath);\n    xmlRoot.children.push(xmlContentGroup);\n\n    // Render guides if configured to do so.\n    if (options.guides) {\n        const color = options.stroke || \"black\";\n        const size = options.strokeWidth || 1;\n\n        // Bounding box.\n        if (options.boundingBox) {\n            const xmlBoundingRect = new XmlElement(\"rect\");\n            xmlBoundingRect.attributes.x = 0;\n            xmlBoundingRect.attributes.y = 0;\n            xmlBoundingRect.attributes.width = options.width;\n            xmlBoundingRect.attributes.height = options.height;\n            xmlBoundingRect.attributes.fill = \"none\";\n            xmlBoundingRect.attributes.stroke = color;\n            xmlBoundingRect.attributes[\"stroke-width\"] = 2 * size;\n            xmlBoundingRect.attributes[\"stroke-dasharray\"] = 2 * size;\n            xmlContentGroup.children.push(xmlBoundingRect);\n        }\n\n        // Points and handles.\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n            const currControl = expandHandle(curr, curr.handleOut);\n            const nextControl = expandHandle(next, next.handleIn);\n\n            const xmlOutgoingHandleLine = new XmlElement(\"line\");\n            xmlOutgoingHandleLine.attributes.x1 = curr.x;\n            xmlOutgoingHandleLine.attributes.y1 = curr.y;\n            xmlOutgoingHandleLine.attributes.x2 = currControl.x;\n            xmlOutgoingHandleLine.attributes.y2 = currControl.y;\n            xmlOutgoingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlOutgoingHandleLine.attributes.stroke = color;\n\n            const xmlIncomingHandleLine = new XmlElement(\"line\");\n            xmlIncomingHandleLine.attributes.x1 = next.x;\n            xmlIncomingHandleLine.attributes.y1 = next.y;\n            xmlIncomingHandleLine.attributes.x2 = nextControl.x;\n            xmlIncomingHandleLine.attributes.y2 = nextControl.y;\n            xmlIncomingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlIncomingHandleLine.attributes.stroke = color;\n            xmlIncomingHandleLine.attributes[\"stroke-dasharray\"] = 2 * size;\n\n            const xmlOutgoingHandleCircle = new XmlElement(\"circle\");\n            xmlOutgoingHandleCircle.attributes.cx = currControl.x;\n            xmlOutgoingHandleCircle.attributes.cy = currControl.y;\n            xmlOutgoingHandleCircle.attributes.r = size;\n            xmlOutgoingHandleCircle.attributes.fill = color;\n\n            const xmlIncomingHandleCircle = new XmlElement(\"circle\");\n            xmlIncomingHandleCircle.attributes.cx = nextControl.x;\n            xmlIncomingHandleCircle.attributes.cy = nextControl.y;\n            xmlIncomingHandleCircle.attributes.r = size;\n            xmlIncomingHandleCircle.attributes.fill = color;\n\n            const xmlPointCircle = new XmlElement(\"circle\");\n            xmlPointCircle.attributes.cx = curr.x;\n            xmlPointCircle.attributes.cy = curr.y;\n            xmlPointCircle.attributes.r = 2 * size;\n            xmlPointCircle.attributes.fill = color;\n\n            xmlContentGroup.children.push(xmlOutgoingHandleLine);\n            xmlContentGroup.children.push(xmlIncomingHandleLine);\n            xmlContentGroup.children.push(xmlOutgoingHandleCircle);\n            xmlContentGroup.children.push(xmlIncomingHandleCircle);\n            xmlContentGroup.children.push(xmlPointCircle);\n        });\n    }\n\n    return xmlRoot;\n};\n\n// Structured element with tag, attributes and children.\nexport class XmlElement {\n    public attributes: Record<string, string | number> = {};\n    public children: any[] = [];\n\n    public constructor(public tag: string) {}\n\n    public render(): string {\n        const attributes = this.renderAttributes();\n        const content = this.renderChildren();\n        if (content === \"\") {\n            return `<${this.tag}${attributes}/>`;\n        }\n        return `<${this.tag}${attributes}>${content}</${this.tag}>`;\n    }\n\n    private renderAttributes(): string {\n        const attributes = Object.keys(this.attributes);\n        if (attributes.length === 0) return \"\";\n        let out = \"\";\n        for (const attribute of attributes) {\n            out += ` ${attribute}=\"${this.attributes[attribute]}\"`;\n        }\n        return out;\n    }\n\n    private renderChildren(): string {\n        let out = \"\";\n        for (const child of this.children) {\n            out += child.render();\n        }\n        return out;\n    }\n}\n","import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + blobOptions.randomness / 10);\n\n    const points = genBlob(\n        3 + blobOptions.extraPoints,\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = blobOptions.size;\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n","import {rand} from \"../internal/rand\";\nimport {renderEditable, XmlElement as InternalXmlElement} from \"../internal/render/svg\";\nimport {genBlob} from \"../internal/gen\";\nimport {mapPoints} from \"../internal/util\";\n\nconst isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\");\nconst isLocalhost = () => location.hostname === \"localhost\" || location.hostname === \"127.0.0.1\";\nconst isFile = () => location.protocol === \"file:\";\nif (!isBrowser() || isLocalhost() || isFile()) {\n    console.warn(\"You are using the legacy blobs API!\\nPlease use 'blobs/v2' instead.\");\n}\n\nexport interface PathOptions {\n    // Bounding box dimensions.\n    size: number;\n\n    // Number of points.\n    complexity: number;\n\n    // Amount of randomness.\n    contrast: number;\n\n    // Value to seed random number generator.\n    seed?: string;\n}\n\nexport interface BlobOptions extends PathOptions {\n    // Fill color.\n    color?: string;\n\n    stroke?: {\n        // Stroke color.\n        color: string;\n\n        // Stroke width.\n        width: number;\n    };\n\n    // Render points, handles and stroke.\n    guides?: boolean;\n}\n\n// Generates an svg document string containing a randomized blob.\nconst blobs = (options: BlobOptions): string => {\n    return blobs.editable(options).render();\n};\n\n// Generates a randomized blob as an editable data structure which can be rendered to an svg document.\nblobs.editable = (options: BlobOptions): XmlElement => {\n    if (!options) {\n        throw new Error(\"no options specified\");\n    }\n\n    // Random number generator.\n    const rgen = rand(options.seed || String(Math.random()));\n\n    if (!options.size) {\n        throw new Error(\"no size specified\");\n    }\n\n    if (!options.stroke && !options.color) {\n        throw new Error(\"no color or stroke specified\");\n    }\n\n    if (options.complexity <= 0 || options.complexity > 1) {\n        throw new Error(\"complexity out of range ]0,1]\");\n    }\n\n    if (options.contrast < 0 || options.contrast > 1) {\n        throw new Error(\"contrast out of range [0,1]\");\n    }\n\n    const count = 3 + Math.floor(14 * options.complexity);\n    const offset = (): number => (1 - 0.8 * options.contrast * rgen()) / Math.E;\n\n    const points = mapPoints(genBlob(count, offset), ({curr}) => {\n        // Scale.\n        curr.x *= options.size;\n        curr.y *= options.size;\n        curr.handleIn.length *= options.size;\n        curr.handleOut.length *= options.size;\n\n        // Flip around x-axis.\n        curr.y = options.size - curr.y;\n        curr.handleIn.angle *= -1;\n        curr.handleOut.angle *= -1;\n\n        return curr;\n    });\n\n    return renderEditable(points, {\n        closed: true,\n        width: options.size,\n        height: options.size,\n        fill: options.color,\n        transform: `rotate(${rgen() * (360 / count)},${options.size / 2},${options.size / 2})`,\n        stroke: options.stroke && options.stroke.color,\n        strokeWidth: options.stroke && options.stroke.width,\n        guides: options.guides,\n    });\n};\n\nexport interface XmlElement {\n    tag: string;\n    attributes: Record<string, string | number>;\n    children: XmlElement[];\n    render(): string;\n}\n\n// Shortcut to create an XmlElement without \"new\";\nblobs.xml = (tag: string): XmlElement => new InternalXmlElement(tag);\n\nexport default blobs;\n"],"names":["rand","seed","a","b","c","d","seedGenerator","str","h","i","length","Math","imul","charCodeAt","xfnv1a","t","copyPoint","p","x","y","handleIn","handleOut","forPoints","points","callback","sibling","pos","mod","curr","index","prev","next","mapPoints","out","args","push","angleOf","dx","dy","angle","atan2","abs","PI","expandHandle","point","handle","cos","sin","smooth","strength","_a","distance","n","sqrt","renderPath","path","getNext","currControl","nextControl","renderEditable","options","stroke","guides","strokeWidth","xmlRoot","XmlElement","attributes","width","height","viewBox","xmlns","xmlContentGroup","transform","color_1","size_1","xmlBlobPath","fill","children","boundingBox","xmlBoundingRect","xmlOutgoingHandleLine","x1","y1","x2","y2","xmlIncomingHandleLine","xmlOutgoingHandleCircle","cx","cy","r","xmlIncomingHandleCircle","xmlPointCircle","tag","this","renderAttributes","content","renderChildren","Object","keys","attributes_1","_i","attribute","render","genBlob","pointCount","offset","randPointOffset","pointX","pointY","smoothingStrength","tan","isBrowser","Function","isLocalhost","location","hostname","isFile","protocol","console","warn","blobs","editable","Error","rgen","String","random","size","color","complexity","contrast","count","floor","E","closed","xml","InternalXmlElement"],"mappings":"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"}
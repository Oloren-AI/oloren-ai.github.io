{"version":3,"file":"index.js","sources":["../../internal/util.ts","../../internal/gen.ts","../../internal/rand.ts","../../internal/animate/timing.ts","../../internal/animate/prepare.ts","../../internal/animate/interpolate.ts","../../internal/animate/frames.ts","../../internal/check.ts","../../internal/animate/state.ts","../../public/animate.ts","../../internal/render/canvas.ts"],"sourcesContent":["import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const coordPoint = (coord: Coord): Point => {\n    return {\n        ...coord,\n        handleIn: {angle: 0, length: 0},\n        handleOut: {angle: 0, length: 0},\n    };\n};\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n","import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + blobOptions.randomness / 10);\n\n    const points = genBlob(\n        3 + blobOptions.extraPoints,\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = blobOptions.size;\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n","// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n","export interface TimingFunc {\n    (percentage: number): number;\n}\n\nconst linear: TimingFunc = (p) => {\n    return p;\n};\n\nconst easeEnd: TimingFunc = (p) => {\n    return 1 - (p - 1) ** 2;\n};\n\nconst easeStart: TimingFunc = (p) => {\n    return 1 - easeEnd(1 - p);\n};\n\nconst ease: TimingFunc = (p) => {\n    return 0.5 + 0.5 * Math.sin(Math.PI * (p + 1.5));\n};\n\nconst elasticEnd =\n    (s: number): TimingFunc =>\n    (p) => {\n        return Math.pow(2, -10 * p) * Math.sin(((p - s / 4) * (2 * Math.PI)) / s) + 1;\n    };\n\n// https://www.desmos.com/calculator/fqisoq1kuw\nexport const timingFunctions = {\n    linear,\n    easeEnd,\n    easeStart,\n    ease,\n    elasticEnd0: elasticEnd(1),\n    elasticEnd1: elasticEnd(0.64),\n    elasticEnd2: elasticEnd(0.32),\n    elasticEnd3: elasticEnd(0.16),\n};\n\n// @ts-ignore: Type assertion.\nconst _: Record<string, TimingFunc> = timingFunctions;\n","import {\n    length,\n    reverse,\n    shift,\n    insertCount,\n    distance,\n    mod,\n    angleOf,\n    coordEqual,\n    mapPoints,\n    forPoints,\n} from \"../util\";\nimport {Point} from \"../types\";\n\nconst optimizeOrder = (a: Point[], b: Point[]): Point[] => {\n    const count = a.length;\n\n    let minTotal = Infinity;\n    let minOffset = 0;\n    let minOffsetBase: Point[] = [];\n\n    const setMinOffset = (points: Point[]) => {\n        for (let i = 0; i < count; i++) {\n            let total = 0;\n            for (let j = 0; j < count; j++) {\n                total += (100 * distance(a[j], points[mod(j + i, count)])) ** 2;\n                if (total > minTotal) break;\n            }\n            if (total <= minTotal) {\n                minTotal = total;\n                minOffset = i;\n                minOffsetBase = points;\n            }\n        }\n    };\n    setMinOffset(b);\n    setMinOffset(reverse(b));\n\n    return shift(minOffset, minOffsetBase);\n};\n\nexport const divide = (count: number, points: Point[]): Point[] => {\n    if (points.length < 3) throw new Error(\"not enough points\");\n    if (count < points.length) throw new Error(\"cannot remove points\");\n    if (count === points.length) return points.slice();\n\n    const lengths: number[] = [];\n    forPoints(points, ({curr, next}) => {\n        lengths.push(length(curr, next()));\n    });\n\n    const divisors = divideLengths(lengths, count - points.length);\n    const out: Point[] = [];\n    for (let i = 0; i < points.length; i++) {\n        const curr: Point = out[out.length - 1] || points[i];\n        const next = points[mod(i + 1, points.length)];\n        out.pop();\n        out.push(...insertCount(divisors[i], curr, next));\n    }\n    const last = out.pop();\n    out[0].handleIn = last!.handleIn;\n\n    return out;\n};\n\n// If point has no handle and is on top of the point before or after it, use the\n// angle of the fixer shape's point at the same index. This is especially useful\n// when all the points of the initial shape are concentrated on the same\n// coordinates and \"expand\" into the target shape.\nconst fixAnglesWith = (fixee: Point[], fixer: Point[]): Point[] => {\n    return mapPoints(fixee, ({index, curr, prev, next}) => {\n        if (curr.handleIn.length === 0 && coordEqual(prev(), curr)) {\n            curr.handleIn.angle = fixer[index].handleIn.angle;\n        }\n        if (curr.handleOut.length === 0 && coordEqual(next(), curr)) {\n            curr.handleOut.angle = fixer[index].handleOut.angle;\n        }\n        return curr;\n    });\n};\n\n// If point has no handle, use angle between before and after points.\nconst fixAnglesSelf = (points: Point[]): Point[] => {\n    return mapPoints(points, ({curr, prev, next}) => {\n        const angle = angleOf(prev(), next());\n        if (curr.handleIn.length === 0) {\n            curr.handleIn.angle = angle + Math.PI;\n        }\n        if (curr.handleOut.length === 0) {\n            curr.handleOut.angle = angle;\n        }\n        return curr;\n    });\n};\n\nconst divideLengths = (lengths: number[], add: number): number[] => {\n    const divisors = lengths.map(() => 1);\n    const sizes = lengths.slice();\n    for (let i = 0; i < add; i++) {\n        let maxSizeIndex = 0;\n        for (let j = 1; j < sizes.length; j++) {\n            if (sizes[j] > sizes[maxSizeIndex]) {\n                maxSizeIndex = j;\n                continue;\n            }\n            if (sizes[j] === sizes[maxSizeIndex]) {\n                if (lengths[j] > lengths[maxSizeIndex]) {\n                    maxSizeIndex = j;\n                }\n            }\n        }\n        divisors[maxSizeIndex]++;\n        sizes[maxSizeIndex] = lengths[maxSizeIndex] / divisors[maxSizeIndex];\n    }\n    return divisors;\n};\n\nexport const prepare = (\n    a: Point[],\n    b: Point[],\n    options: {rawAngles: boolean; divideRatio: number},\n): [Point[], Point[]] => {\n    const pointCount = options.divideRatio * Math.max(a.length, b.length);\n    const aNorm = divide(pointCount, a);\n    const bNorm = divide(pointCount, b);\n    const bOpt = optimizeOrder(aNorm, bNorm);\n    return [\n        options.rawAngles ? aNorm : fixAnglesWith(fixAnglesSelf(aNorm), bOpt),\n        options.rawAngles ? bOpt : fixAnglesWith(fixAnglesSelf(bOpt), aNorm),\n    ];\n};\n","import {Point} from \"../types\";\nimport {split, splitLine, mod, smooth, mapPoints} from \"../util\";\n\n// Interpolates between angles a and b. Angles are normalized to avoid unnecessary rotation.\n// Direction is chosen to produce the smallest possible movement.\nconst interpolateAngle = (percentage: number, a: number, b: number): number => {\n    const tau = Math.PI * 2;\n    let aNorm = mod(a, tau);\n    let bNorm = mod(b, tau);\n    if (Math.abs(aNorm - bNorm) > Math.PI) {\n        if (aNorm < bNorm) {\n            aNorm += tau;\n        } else {\n            bNorm += tau;\n        }\n    }\n    return split(percentage, aNorm, bNorm);\n};\n\n// Interpolates linearly between a and b. Can only interpolate between point lists that have the\n// same number of points. Easing effects can be applied to the percentage given to this function.\n// Percentages outside the 0-1 range are supported.\nexport const interpolateBetween = (percentage: number, a: Point[], b: Point[]): Point[] => {\n    if (a.length !== b.length) throw new Error(\"must have equal number of points\");\n\n    // Clamped range for use in values that could look incorrect otherwise.\n    // ex. Handles that invert if their value goes negative (creates loops at corners).\n    const clamped = Math.min(1, Math.max(0, percentage));\n\n    const points: Point[] = [];\n    for (let i = 0; i < a.length; i++) {\n        points.push({\n            ...splitLine(percentage, a[i], b[i]),\n            handleIn: {\n                angle: interpolateAngle(percentage, a[i].handleIn.angle, b[i].handleIn.angle),\n                length: split(clamped, a[i].handleIn.length, b[i].handleIn.length),\n            },\n            handleOut: {\n                angle: interpolateAngle(percentage, a[i].handleOut.angle, b[i].handleOut.angle),\n                length: split(clamped, a[i].handleOut.length, b[i].handleOut.length),\n            },\n        });\n    }\n    return points;\n};\n\n// Interpolates between a and b while applying a smoothing effect. Smoothing effect's strength is\n// relative to how far away the percentage is from either 0 or 1. It is strongest in the middle of\n// the animation (percentage = 0.5) or when bounds are exceeded (percentage = 1.8).\nexport const interpolateBetweenSmooth = (\n    strength: number,\n    percentage: number,\n    a: Point[],\n    b: Point[],\n): Point[] => {\n    strength *= Math.min(1, Math.min(Math.abs(0 - percentage), Math.abs(1 - percentage)));\n    const interpolated = interpolateBetween(percentage, a, b);\n    const smoothed = smooth(interpolated, Math.sqrt(strength + 0.25) / 3);\n    return mapPoints(interpolated, ({index, curr}) => {\n        const sp = smoothed[index];\n        curr.handleIn.angle = interpolateAngle(strength, curr.handleIn.angle, sp.handleIn.angle);\n        curr.handleIn.length = split(strength, curr.handleIn.length, sp.handleIn.length);\n        curr.handleOut.angle = interpolateAngle(strength, curr.handleOut.angle, sp.handleOut.angle);\n        curr.handleOut.length = split(strength, curr.handleOut.length, sp.handleOut.length);\n        return curr;\n    });\n};\n","import {TimingFunc, timingFunctions} from \"./timing\";\nimport {Point} from \"../types\";\nimport {prepare} from \"./prepare\";\nimport {interpolateBetween} from \"./interpolate\";\n\nexport interface Keyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?: keyof typeof timingFunctions;\n}\n\nexport interface InternalKeyframe {\n    id: string;\n    timestamp: number;\n    timingFunction: TimingFunc;\n    initialPoints: Point[];\n    transitionSourceFrameIndex: number;\n    isSynthetic: boolean;\n}\n\nexport interface RenderCache {\n    [frameId: string]: {\n        preparedEndPoints?: Point[];\n        preparedStartPoints?: Point[];\n    };\n}\n\nexport interface RenderInput {\n    currentFrames: InternalKeyframe[];\n    timestamp: number;\n    renderCache: RenderCache;\n}\n\nexport interface RenderOutput {\n    points: Point[];\n    lastFrameId: string | null;\n    renderCache: RenderCache;\n}\n\nexport interface TransitionInput<T extends Keyframe> extends RenderInput {\n    newFrames: T[];\n    shapeGenerator: (keyframe: T) => Point[];\n}\n\nexport interface TransitionOutput {\n    newFrames: InternalKeyframe[];\n}\n\nconst genId = (): string => {\n    return String(Math.random()).substr(2);\n};\n\nexport const renderFramesAt = (input: RenderInput): RenderOutput => {\n    const {renderCache, currentFrames} = input;\n\n    if (currentFrames.length === 0) {\n        return {renderCache, lastFrameId: null, points: []};\n    }\n\n    // Animation freezes at the final shape if there are no more keyframes.\n    if (currentFrames.length === 1) {\n        const first = currentFrames[0];\n        return {renderCache, lastFrameId: first.id, points: first.initialPoints};\n    }\n\n    // Find the start/end keyframes according to the timestamp.\n    let startKeyframe = currentFrames[0];\n    let endKeyframe = currentFrames[1];\n    for (let i = 2; i < currentFrames.length; i++) {\n        if (endKeyframe.timestamp > input.timestamp) break;\n        startKeyframe = currentFrames[i - 1];\n        endKeyframe = currentFrames[i];\n    }\n\n    // Return original end shape when past the end of the animation.\n    const endKeyframeIsLast = endKeyframe === currentFrames[currentFrames.length - 1];\n    const animationIsPastEndKeyframe = endKeyframe.timestamp < input.timestamp;\n    if (animationIsPastEndKeyframe && endKeyframeIsLast) {\n        return {\n            renderCache,\n            lastFrameId: endKeyframe.id,\n            points: endKeyframe.initialPoints,\n        };\n    }\n\n    // Use and cache prepared points for current interpolation.\n    let preparedStartPoints: Point[] | undefined =\n        renderCache[startKeyframe.id]?.preparedStartPoints;\n    let preparedEndPoints: Point[] | undefined = renderCache[endKeyframe.id]?.preparedEndPoints;\n    if (!preparedStartPoints || !preparedEndPoints) {\n        [preparedStartPoints, preparedEndPoints] = prepare(\n            startKeyframe.initialPoints,\n            endKeyframe.initialPoints,\n            {rawAngles: false, divideRatio: 1},\n        );\n\n        renderCache[startKeyframe.id] = renderCache[startKeyframe.id] || {};\n        renderCache[startKeyframe.id].preparedStartPoints = preparedStartPoints;\n\n        renderCache[endKeyframe.id] = renderCache[endKeyframe.id] || {};\n        renderCache[endKeyframe.id].preparedEndPoints = preparedEndPoints;\n    }\n\n    // Calculate progress between frames as a fraction.\n    const progress =\n        (input.timestamp - startKeyframe.timestamp) /\n        (endKeyframe.timestamp - startKeyframe.timestamp);\n\n    // Keep progress within expected range (ex. division by 0).\n    const clampedProgress = Math.max(0, Math.min(1, progress));\n\n    // Apply timing function of end frame.\n    const adjustedProgress = endKeyframe.timingFunction(clampedProgress);\n\n    return {\n        renderCache,\n        lastFrameId: clampedProgress === 1 ? endKeyframe.id : startKeyframe.id,\n        points: interpolateBetween(adjustedProgress, preparedStartPoints, preparedEndPoints),\n    };\n};\n\nexport const transitionFrames = <T extends Keyframe>(\n    input: TransitionInput<T>,\n): TransitionOutput => {\n    // Erase all old frames.\n    const newInternalFrames: InternalKeyframe[] = [];\n\n    // Reset animation when given no keyframes.\n    if (input.newFrames.length === 0) {\n        return {newFrames: newInternalFrames};\n    }\n\n    // Add current state as initial frame.\n    const currentState = renderFramesAt(input);\n    if (currentState.lastFrameId === null) {\n        // If there is currently no shape being rendered, use a point in the\n        // center of the next frame as the initial point.\n        const firstShape = input.shapeGenerator(input.newFrames[0]);\n        let firstShapeCenterPoint: Point = {\n            x: 0,\n            y: 0,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        };\n        for (const point of firstShape) {\n            firstShapeCenterPoint.x += point.x / firstShape.length;\n            firstShapeCenterPoint.y += point.y / firstShape.length;\n        }\n        currentState.points = [firstShapeCenterPoint, firstShapeCenterPoint, firstShapeCenterPoint];\n    }\n    newInternalFrames.push({\n        id: genId(),\n        initialPoints: currentState.points,\n        timestamp: input.timestamp,\n        timingFunction: timingFunctions.linear,\n        transitionSourceFrameIndex: -1,\n        isSynthetic: true,\n    });\n\n    // Generate and add new frames.\n    let totalOffset = 0;\n    for (let i = 0; i < input.newFrames.length; i++) {\n        const keyframe = input.newFrames[i];\n\n        // Copy previous frame when current one has a delay.\n        if (keyframe.delay) {\n            totalOffset += keyframe.delay;\n            const prevFrame = newInternalFrames[newInternalFrames.length - 1];\n            newInternalFrames.push({\n                id: genId(),\n                initialPoints: prevFrame.initialPoints,\n                timestamp: input.timestamp + totalOffset,\n                timingFunction: timingFunctions.linear,\n                transitionSourceFrameIndex: i - 1,\n                isSynthetic: true,\n            });\n        }\n\n        totalOffset += keyframe.duration;\n        newInternalFrames.push({\n            id: genId(),\n            initialPoints: input.shapeGenerator(keyframe),\n            timestamp: input.timestamp + totalOffset,\n            timingFunction: timingFunctions[keyframe.timingFunction || \"linear\"],\n            transitionSourceFrameIndex: i,\n            isSynthetic: false,\n        });\n    }\n\n    return {newFrames: newInternalFrames};\n};\n","import {timingFunctions} from \"./animate/timing\";\n\nconst typeCheck = (name: string, val: any, expected: string[]) => {\n    let actual: string = typeof val;\n    if (actual === \"number\" && isNaN(val)) actual = \"NaN\";\n    if (actual === \"object\" && val === null) actual = \"null\";\n    if (!expected.includes(actual)) {\n        throw `\"${name}\" should have type \"${expected.join(\"|\")}\" but was \"${actual}\".`;\n    }\n};\n\nexport const checkKeyframeOptions = (keyframe: any) => {\n    typeCheck(`keyframe`, keyframe, [\"object\"]);\n    const {delay, duration, timingFunction, callback} = keyframe;\n    typeCheck(`delay`, delay, [\"number\", \"undefined\"]);\n    if (delay && delay < 0) throw `delay is invalid \"${delay}\".`;\n    typeCheck(`duration`, duration, [\"number\"]);\n    if (duration && duration < 0) throw `duration is invalid \"${duration}\".`;\n    typeCheck(`timingFunction`, timingFunction, [\"string\", \"undefined\"]);\n    if (timingFunction && !(timingFunctions as any)[timingFunction])\n        throw `\".timingFunction\" is not recognized \"${timingFunction}\".`;\n    typeCheck(`callback`, callback, [\"function\", \"undefined\"]);\n};\n\nexport const checkBlobOptions = (blobOptions: any) => {\n    typeCheck(`blobOptions`, blobOptions, [\"object\"]);\n    const {seed, extraPoints, randomness, size} = blobOptions;\n    typeCheck(`blobOptions.seed`, seed, [\"string\", \"number\"]);\n    typeCheck(`blobOptions.extraPoints`, extraPoints, [\"number\"]);\n    if (extraPoints < 0) throw `blobOptions.extraPoints is invalid \"${extraPoints}\".`;\n    typeCheck(`blobOptions.randomness`, randomness, [\"number\"]);\n    if (randomness < 0) throw `blobOptions.randomness is invalid \"${randomness}\".`;\n    typeCheck(`blobOptions.size`, size, [\"number\"]);\n    if (size < 0) throw `blobOptions.size is invalid \"${size}\".`;\n};\n\nexport const checkCanvasOptions = (canvasOptions: any) => {\n    typeCheck(`canvasOptions`, canvasOptions, [\"object\", \"undefined\"]);\n    if (canvasOptions) {\n        const {offsetX, offsetY} = canvasOptions;\n        typeCheck(`canvasOptions.offsetX`, offsetX, [\"number\", \"undefined\"]);\n        typeCheck(`canvasOptions.offsetY`, offsetY, [\"number\", \"undefined\"]);\n    }\n};\n\nexport const checkSvgOptions = (svgOptions: any) => {\n    typeCheck(`svgOptions`, svgOptions, [\"object\", \"undefined\"]);\n    if (svgOptions) {\n        const {fill, stroke, strokeWidth} = svgOptions;\n        typeCheck(`svgOptions.fill`, fill, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.stroke`, stroke, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.strokeWidth`, strokeWidth, [\"number\", \"undefined\"]);\n    }\n};\n","import {Point} from \"../types\";\nimport {RenderCache, InternalKeyframe, renderFramesAt, transitionFrames, Keyframe} from \"./frames\";\n\ninterface CallbackKeyframe extends Keyframe {\n    callback?: () => void;\n}\n\ninterface CallbackStore {\n    [frameId: string]: () => void;\n}\n\nexport const statefulAnimationGenerator =\n    <K extends CallbackKeyframe, T>(\n        generator: (keyframe: K) => Point[],\n        renderer: (points: Point[]) => T,\n        checker: (keyframe: K, index: number) => void,\n    ) =>\n    () => {\n        let internalFrames: InternalKeyframe[] = [];\n        let renderCache: RenderCache = {};\n        let callbackStore: CallbackStore = {};\n\n        // Keep track of paused state.\n        let pausedAt = 0;\n        let pauseOffset = 0;\n        const getAnimationTimestamp = () => Date.now() - pauseOffset;\n        const isPaused = () => pausedAt !== 0;\n\n        const play = () => {\n            if (!isPaused()) return;\n            pauseOffset += getAnimationTimestamp() - pausedAt;\n            pausedAt = 0;\n        };\n\n        const pause = () => {\n            if (isPaused()) return;\n            pausedAt = getAnimationTimestamp();\n        };\n\n        const playPause = () => {\n            ``;\n            if (isPaused()) {\n                play();\n            } else {\n                pause();\n            }\n        };\n\n        const renderFrame = (): T => {\n            const renderOutput = renderFramesAt({\n                renderCache: renderCache,\n                timestamp: isPaused() ? pausedAt : getAnimationTimestamp(),\n                currentFrames: internalFrames,\n            });\n\n            // Update render cache with returned value.\n            renderCache = renderOutput.renderCache;\n\n            // Invoke callback if defined and the first time the frame is reached.\n            if (renderOutput.lastFrameId && callbackStore[renderOutput.lastFrameId]) {\n                callbackStore[renderOutput.lastFrameId]();\n                delete callbackStore[renderOutput.lastFrameId];\n            }\n\n            return renderer(renderOutput.points);\n        };\n\n        const transition = (...keyframes: K[]) => {\n            // Make sure frame info is valid.\n            for (let i = 0; i < keyframes.length; i++) {\n                checker(keyframes[i], i);\n            }\n\n            const transitionOutput = transitionFrames<K>({\n                renderCache: renderCache,\n                timestamp: getAnimationTimestamp(),\n                currentFrames: internalFrames,\n                newFrames: keyframes,\n                shapeGenerator: generator,\n            });\n\n            // Reset internal state..\n            internalFrames = transitionOutput.newFrames;\n            callbackStore = {};\n            renderCache = {};\n\n            // Populate callback store using returned frame ids.\n            for (const newFrame of internalFrames) {\n                if (newFrame.isSynthetic) continue;\n                const {callback} = keyframes[newFrame.transitionSourceFrameIndex];\n                if (callback) callbackStore[newFrame.id] = callback;\n            }\n        };\n\n        return {renderFrame, transition, play, pause, playPause};\n    };\n","import {Point} from \"../internal/types\";\nimport {renderPath2D} from \"../internal/render/canvas\";\nimport {genFromOptions} from \"../internal/gen\";\nimport {mapPoints} from \"../internal/util\";\nimport {statefulAnimationGenerator} from \"../internal/animate/state\";\nimport {checkBlobOptions, checkCanvasOptions, checkKeyframeOptions} from \"../internal/check\";\n\nexport interface CanvasKeyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?:\n        | \"linear\"\n        | \"easeEnd\"\n        | \"easeStart\"\n        | \"ease\"\n        | \"elasticEnd0\"\n        | \"elasticEnd1\"\n        | \"elasticEnd2\"\n        | \"elasticEnd3\";\n    callback?: () => void;\n    blobOptions: {\n        seed: number | string;\n        randomness: number;\n        extraPoints: number;\n        size: number;\n    };\n    canvasOptions?: {\n        offsetX?: number;\n        offsetY?: number;\n    };\n}\n\nconst canvasBlobGenerator = (keyframe: CanvasKeyframe): Point[] => {\n    return mapPoints(genFromOptions(keyframe.blobOptions), ({curr}) => {\n        curr.x += keyframe?.canvasOptions?.offsetX || 0;\n        curr.y += keyframe?.canvasOptions?.offsetY || 0;\n        return curr;\n    });\n};\n\nconst canvasKeyframeChecker = (keyframe: CanvasKeyframe, index: number) => {\n    try {\n        checkBlobOptions(keyframe.blobOptions);\n        checkCanvasOptions(keyframe.canvasOptions);\n        checkKeyframeOptions(keyframe);\n    } catch (e) {\n        throw `(blobs2): keyframe ${index}: ${e}`;\n    }\n};\n\nexport const canvasPath = statefulAnimationGenerator(\n    canvasBlobGenerator,\n    renderPath2D,\n    canvasKeyframeChecker,\n);\n","import {Coord, Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nconst pointSize = 2;\nconst infoSpacing = 20;\n\nexport const clear = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\nexport const drawInfo = (ctx: CanvasRenderingContext2D, pos: number, label: string, value: any) => {\n    ctx.fillText(`${label}: ${value}`, infoSpacing, (pos + 1) * infoSpacing);\n};\n\nconst drawLine = (ctx: CanvasRenderingContext2D, a: Coord, b: Coord, style: string) => {\n    const backupStrokeStyle = ctx.strokeStyle;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.strokeStyle = backupStrokeStyle;\n};\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, p: Coord, style: string) => {\n    const backupFillStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);\n    ctx.fillStyle = style;\n    ctx.fill();\n    ctx.fillStyle = backupFillStyle;\n};\n\nexport const drawClosed = (ctx: CanvasRenderingContext2D, debug: boolean, points: Point[]) => {\n    if (points.length < 2) throw new Error(\"not enough points\");\n\n    // Draw debug points.\n    if (debug) {\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n\n            // Compute coordinates of handles.\n            const currHandle = expandHandle(curr, curr.handleOut);\n            const nextHandle = expandHandle(next, next.handleIn);\n\n            drawPoint(ctx, curr, \"\");\n            drawLine(ctx, curr, currHandle, \"#ccc\");\n            drawLine(ctx, next, nextHandle, \"#b6b\");\n        });\n    }\n\n    ctx.stroke(renderPath2D(points));\n};\n\nexport const renderPath2D = (points: Point[]): Path2D => {\n    const path = new Path2D();\n\n    if (points.length < 1) return path;\n    path.moveTo(points[0].x, points[0].y);\n\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currHandle = expandHandle(curr, curr.handleOut);\n        const nextHandle = expandHandle(next, next.handleIn);\n        path.bezierCurveTo(currHandle.x, currHandle.y, nextHandle.x, nextHandle.y, next.x, next.y);\n    });\n\n    return path;\n};\n"],"names":["copyPoint","p","x","y","handleIn","handleOut","forPoints","points","callback","i","sibling","pos","mod","length","curr","index","prev","next","mapPoints","out","args","push","coordEqual","a","b","angleOf","dx","dy","angle","Math","atan2","abs","PI","expandHandle","point","handle","cos","sin","collapseHandle","sqrt","split","percentage","genBlob","pointCount","offset","randPointOffset","pointX","pointY","strength","smoothingStrength","tan","_a","distance","genFromOptions","blobOptions","c","d","rgen","seedGenerator","str","h","imul","charCodeAt","xfnv1a","seed","String","t","rangeStart","randomness","extraPoints","size","easeEnd","optimizeOrder","setMinOffset","count","total","j","minTotal","minOffset","minOffsetBase","Infinity","divide","Error","slice","lengths","aHandle","bHandle","divisors","divideLengths","pop","insertCount","last","fixAnglesWith","fixee","fixer","fixAnglesSelf","interpolateAngle","tau","aNorm","bNorm","genId","random","substr","renderFramesAt","input","renderCache","currentFrames","lastFrameId","first","id","initialPoints","startKeyframe","endKeyframe","timestamp","endKeyframeIsLast","options","preparedStartPoints","preparedEndPoints","rawAngles","divideRatio","max","bOpt","progress","clampedProgress","min","adjustedProgress","timingFunction","clamped","splitLine","interpolateBetween","typeCheck","name","val","expected","actual","isNaN","includes","join","generator","renderer","checker","e","cHandle","eHandle","f","g","dCoord","insertAt","n","elasticEnd","s","pow","timingFunctions","linear","easeStart","ease","elasticEnd0","elasticEnd1","elasticEnd2","elasticEnd3","add","map","sizes","maxSizeIndex","canvasPath","keyframe","canvasOptions","offsetX","offsetY","path","Path2D","moveTo","getNext","currHandle","nextHandle","bezierCurveTo","checkBlobOptions","delay","duration","checkKeyframeOptions","getAnimationTimestamp","Date","now","pauseOffset","isPaused","pausedAt","play","pause","internalFrames","callbackStore","renderFrame","renderOutput","transition","_i","keyframes","transitionOutput","newInternalFrames","newFrames","currentState","firstShape","shapeGenerator","firstShapeCenterPoint","firstShape_1","transitionSourceFrameIndex","isSynthetic","totalOffset","prevFrame","transitionFrames","internalFrames_1","newFrame","playPause"],"mappings":"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"}
{"version":3,"file":"index.module.js","sources":["../../internal/util.ts","../../internal/render/canvas.ts","../../internal/rand.ts","../../internal/gen.ts","../../internal/animate/timing.ts","../../internal/animate/prepare.ts","../../internal/animate/interpolate.ts","../../internal/animate/frames.ts","../../internal/animate/state.ts","../../internal/check.ts","../../public/animate.ts"],"sourcesContent":["import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const coordPoint = (coord: Coord): Point => {\n    return {\n        ...coord,\n        handleIn: {angle: 0, length: 0},\n        handleOut: {angle: 0, length: 0},\n    };\n};\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n","import {Coord, Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nconst pointSize = 2;\nconst infoSpacing = 20;\n\nexport const clear = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\nexport const drawInfo = (ctx: CanvasRenderingContext2D, pos: number, label: string, value: any) => {\n    ctx.fillText(`${label}: ${value}`, infoSpacing, (pos + 1) * infoSpacing);\n};\n\nconst drawLine = (ctx: CanvasRenderingContext2D, a: Coord, b: Coord, style: string) => {\n    const backupStrokeStyle = ctx.strokeStyle;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.strokeStyle = backupStrokeStyle;\n};\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, p: Coord, style: string) => {\n    const backupFillStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);\n    ctx.fillStyle = style;\n    ctx.fill();\n    ctx.fillStyle = backupFillStyle;\n};\n\nexport const drawClosed = (ctx: CanvasRenderingContext2D, debug: boolean, points: Point[]) => {\n    if (points.length < 2) throw new Error(\"not enough points\");\n\n    // Draw debug points.\n    if (debug) {\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n\n            // Compute coordinates of handles.\n            const currHandle = expandHandle(curr, curr.handleOut);\n            const nextHandle = expandHandle(next, next.handleIn);\n\n            drawPoint(ctx, curr, \"\");\n            drawLine(ctx, curr, currHandle, \"#ccc\");\n            drawLine(ctx, next, nextHandle, \"#b6b\");\n        });\n    }\n\n    ctx.stroke(renderPath2D(points));\n};\n\nexport const renderPath2D = (points: Point[]): Path2D => {\n    const path = new Path2D();\n\n    if (points.length < 1) return path;\n    path.moveTo(points[0].x, points[0].y);\n\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currHandle = expandHandle(curr, curr.handleOut);\n        const nextHandle = expandHandle(next, next.handleIn);\n        path.bezierCurveTo(currHandle.x, currHandle.y, nextHandle.x, nextHandle.y, next.x, next.y);\n    });\n\n    return path;\n};\n","// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n","import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + blobOptions.randomness / 10);\n\n    const points = genBlob(\n        3 + blobOptions.extraPoints,\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = blobOptions.size;\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n","export interface TimingFunc {\n    (percentage: number): number;\n}\n\nconst linear: TimingFunc = (p) => {\n    return p;\n};\n\nconst easeEnd: TimingFunc = (p) => {\n    return 1 - (p - 1) ** 2;\n};\n\nconst easeStart: TimingFunc = (p) => {\n    return 1 - easeEnd(1 - p);\n};\n\nconst ease: TimingFunc = (p) => {\n    return 0.5 + 0.5 * Math.sin(Math.PI * (p + 1.5));\n};\n\nconst elasticEnd =\n    (s: number): TimingFunc =>\n    (p) => {\n        return Math.pow(2, -10 * p) * Math.sin(((p - s / 4) * (2 * Math.PI)) / s) + 1;\n    };\n\n// https://www.desmos.com/calculator/fqisoq1kuw\nexport const timingFunctions = {\n    linear,\n    easeEnd,\n    easeStart,\n    ease,\n    elasticEnd0: elasticEnd(1),\n    elasticEnd1: elasticEnd(0.64),\n    elasticEnd2: elasticEnd(0.32),\n    elasticEnd3: elasticEnd(0.16),\n};\n\n// @ts-ignore: Type assertion.\nconst _: Record<string, TimingFunc> = timingFunctions;\n","import {\n    length,\n    reverse,\n    shift,\n    insertCount,\n    distance,\n    mod,\n    angleOf,\n    coordEqual,\n    mapPoints,\n    forPoints,\n} from \"../util\";\nimport {Point} from \"../types\";\n\nconst optimizeOrder = (a: Point[], b: Point[]): Point[] => {\n    const count = a.length;\n\n    let minTotal = Infinity;\n    let minOffset = 0;\n    let minOffsetBase: Point[] = [];\n\n    const setMinOffset = (points: Point[]) => {\n        for (let i = 0; i < count; i++) {\n            let total = 0;\n            for (let j = 0; j < count; j++) {\n                total += (100 * distance(a[j], points[mod(j + i, count)])) ** 2;\n                if (total > minTotal) break;\n            }\n            if (total <= minTotal) {\n                minTotal = total;\n                minOffset = i;\n                minOffsetBase = points;\n            }\n        }\n    };\n    setMinOffset(b);\n    setMinOffset(reverse(b));\n\n    return shift(minOffset, minOffsetBase);\n};\n\nexport const divide = (count: number, points: Point[]): Point[] => {\n    if (points.length < 3) throw new Error(\"not enough points\");\n    if (count < points.length) throw new Error(\"cannot remove points\");\n    if (count === points.length) return points.slice();\n\n    const lengths: number[] = [];\n    forPoints(points, ({curr, next}) => {\n        lengths.push(length(curr, next()));\n    });\n\n    const divisors = divideLengths(lengths, count - points.length);\n    const out: Point[] = [];\n    for (let i = 0; i < points.length; i++) {\n        const curr: Point = out[out.length - 1] || points[i];\n        const next = points[mod(i + 1, points.length)];\n        out.pop();\n        out.push(...insertCount(divisors[i], curr, next));\n    }\n    const last = out.pop();\n    out[0].handleIn = last!.handleIn;\n\n    return out;\n};\n\n// If point has no handle and is on top of the point before or after it, use the\n// angle of the fixer shape's point at the same index. This is especially useful\n// when all the points of the initial shape are concentrated on the same\n// coordinates and \"expand\" into the target shape.\nconst fixAnglesWith = (fixee: Point[], fixer: Point[]): Point[] => {\n    return mapPoints(fixee, ({index, curr, prev, next}) => {\n        if (curr.handleIn.length === 0 && coordEqual(prev(), curr)) {\n            curr.handleIn.angle = fixer[index].handleIn.angle;\n        }\n        if (curr.handleOut.length === 0 && coordEqual(next(), curr)) {\n            curr.handleOut.angle = fixer[index].handleOut.angle;\n        }\n        return curr;\n    });\n};\n\n// If point has no handle, use angle between before and after points.\nconst fixAnglesSelf = (points: Point[]): Point[] => {\n    return mapPoints(points, ({curr, prev, next}) => {\n        const angle = angleOf(prev(), next());\n        if (curr.handleIn.length === 0) {\n            curr.handleIn.angle = angle + Math.PI;\n        }\n        if (curr.handleOut.length === 0) {\n            curr.handleOut.angle = angle;\n        }\n        return curr;\n    });\n};\n\nconst divideLengths = (lengths: number[], add: number): number[] => {\n    const divisors = lengths.map(() => 1);\n    const sizes = lengths.slice();\n    for (let i = 0; i < add; i++) {\n        let maxSizeIndex = 0;\n        for (let j = 1; j < sizes.length; j++) {\n            if (sizes[j] > sizes[maxSizeIndex]) {\n                maxSizeIndex = j;\n                continue;\n            }\n            if (sizes[j] === sizes[maxSizeIndex]) {\n                if (lengths[j] > lengths[maxSizeIndex]) {\n                    maxSizeIndex = j;\n                }\n            }\n        }\n        divisors[maxSizeIndex]++;\n        sizes[maxSizeIndex] = lengths[maxSizeIndex] / divisors[maxSizeIndex];\n    }\n    return divisors;\n};\n\nexport const prepare = (\n    a: Point[],\n    b: Point[],\n    options: {rawAngles: boolean; divideRatio: number},\n): [Point[], Point[]] => {\n    const pointCount = options.divideRatio * Math.max(a.length, b.length);\n    const aNorm = divide(pointCount, a);\n    const bNorm = divide(pointCount, b);\n    const bOpt = optimizeOrder(aNorm, bNorm);\n    return [\n        options.rawAngles ? aNorm : fixAnglesWith(fixAnglesSelf(aNorm), bOpt),\n        options.rawAngles ? bOpt : fixAnglesWith(fixAnglesSelf(bOpt), aNorm),\n    ];\n};\n","import {Point} from \"../types\";\nimport {split, splitLine, mod, smooth, mapPoints} from \"../util\";\n\n// Interpolates between angles a and b. Angles are normalized to avoid unnecessary rotation.\n// Direction is chosen to produce the smallest possible movement.\nconst interpolateAngle = (percentage: number, a: number, b: number): number => {\n    const tau = Math.PI * 2;\n    let aNorm = mod(a, tau);\n    let bNorm = mod(b, tau);\n    if (Math.abs(aNorm - bNorm) > Math.PI) {\n        if (aNorm < bNorm) {\n            aNorm += tau;\n        } else {\n            bNorm += tau;\n        }\n    }\n    return split(percentage, aNorm, bNorm);\n};\n\n// Interpolates linearly between a and b. Can only interpolate between point lists that have the\n// same number of points. Easing effects can be applied to the percentage given to this function.\n// Percentages outside the 0-1 range are supported.\nexport const interpolateBetween = (percentage: number, a: Point[], b: Point[]): Point[] => {\n    if (a.length !== b.length) throw new Error(\"must have equal number of points\");\n\n    // Clamped range for use in values that could look incorrect otherwise.\n    // ex. Handles that invert if their value goes negative (creates loops at corners).\n    const clamped = Math.min(1, Math.max(0, percentage));\n\n    const points: Point[] = [];\n    for (let i = 0; i < a.length; i++) {\n        points.push({\n            ...splitLine(percentage, a[i], b[i]),\n            handleIn: {\n                angle: interpolateAngle(percentage, a[i].handleIn.angle, b[i].handleIn.angle),\n                length: split(clamped, a[i].handleIn.length, b[i].handleIn.length),\n            },\n            handleOut: {\n                angle: interpolateAngle(percentage, a[i].handleOut.angle, b[i].handleOut.angle),\n                length: split(clamped, a[i].handleOut.length, b[i].handleOut.length),\n            },\n        });\n    }\n    return points;\n};\n\n// Interpolates between a and b while applying a smoothing effect. Smoothing effect's strength is\n// relative to how far away the percentage is from either 0 or 1. It is strongest in the middle of\n// the animation (percentage = 0.5) or when bounds are exceeded (percentage = 1.8).\nexport const interpolateBetweenSmooth = (\n    strength: number,\n    percentage: number,\n    a: Point[],\n    b: Point[],\n): Point[] => {\n    strength *= Math.min(1, Math.min(Math.abs(0 - percentage), Math.abs(1 - percentage)));\n    const interpolated = interpolateBetween(percentage, a, b);\n    const smoothed = smooth(interpolated, Math.sqrt(strength + 0.25) / 3);\n    return mapPoints(interpolated, ({index, curr}) => {\n        const sp = smoothed[index];\n        curr.handleIn.angle = interpolateAngle(strength, curr.handleIn.angle, sp.handleIn.angle);\n        curr.handleIn.length = split(strength, curr.handleIn.length, sp.handleIn.length);\n        curr.handleOut.angle = interpolateAngle(strength, curr.handleOut.angle, sp.handleOut.angle);\n        curr.handleOut.length = split(strength, curr.handleOut.length, sp.handleOut.length);\n        return curr;\n    });\n};\n","import {TimingFunc, timingFunctions} from \"./timing\";\nimport {Point} from \"../types\";\nimport {prepare} from \"./prepare\";\nimport {interpolateBetween} from \"./interpolate\";\n\nexport interface Keyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?: keyof typeof timingFunctions;\n}\n\nexport interface InternalKeyframe {\n    id: string;\n    timestamp: number;\n    timingFunction: TimingFunc;\n    initialPoints: Point[];\n    transitionSourceFrameIndex: number;\n    isSynthetic: boolean;\n}\n\nexport interface RenderCache {\n    [frameId: string]: {\n        preparedEndPoints?: Point[];\n        preparedStartPoints?: Point[];\n    };\n}\n\nexport interface RenderInput {\n    currentFrames: InternalKeyframe[];\n    timestamp: number;\n    renderCache: RenderCache;\n}\n\nexport interface RenderOutput {\n    points: Point[];\n    lastFrameId: string | null;\n    renderCache: RenderCache;\n}\n\nexport interface TransitionInput<T extends Keyframe> extends RenderInput {\n    newFrames: T[];\n    shapeGenerator: (keyframe: T) => Point[];\n}\n\nexport interface TransitionOutput {\n    newFrames: InternalKeyframe[];\n}\n\nconst genId = (): string => {\n    return String(Math.random()).substr(2);\n};\n\nexport const renderFramesAt = (input: RenderInput): RenderOutput => {\n    const {renderCache, currentFrames} = input;\n\n    if (currentFrames.length === 0) {\n        return {renderCache, lastFrameId: null, points: []};\n    }\n\n    // Animation freezes at the final shape if there are no more keyframes.\n    if (currentFrames.length === 1) {\n        const first = currentFrames[0];\n        return {renderCache, lastFrameId: first.id, points: first.initialPoints};\n    }\n\n    // Find the start/end keyframes according to the timestamp.\n    let startKeyframe = currentFrames[0];\n    let endKeyframe = currentFrames[1];\n    for (let i = 2; i < currentFrames.length; i++) {\n        if (endKeyframe.timestamp > input.timestamp) break;\n        startKeyframe = currentFrames[i - 1];\n        endKeyframe = currentFrames[i];\n    }\n\n    // Return original end shape when past the end of the animation.\n    const endKeyframeIsLast = endKeyframe === currentFrames[currentFrames.length - 1];\n    const animationIsPastEndKeyframe = endKeyframe.timestamp < input.timestamp;\n    if (animationIsPastEndKeyframe && endKeyframeIsLast) {\n        return {\n            renderCache,\n            lastFrameId: endKeyframe.id,\n            points: endKeyframe.initialPoints,\n        };\n    }\n\n    // Use and cache prepared points for current interpolation.\n    let preparedStartPoints: Point[] | undefined =\n        renderCache[startKeyframe.id]?.preparedStartPoints;\n    let preparedEndPoints: Point[] | undefined = renderCache[endKeyframe.id]?.preparedEndPoints;\n    if (!preparedStartPoints || !preparedEndPoints) {\n        [preparedStartPoints, preparedEndPoints] = prepare(\n            startKeyframe.initialPoints,\n            endKeyframe.initialPoints,\n            {rawAngles: false, divideRatio: 1},\n        );\n\n        renderCache[startKeyframe.id] = renderCache[startKeyframe.id] || {};\n        renderCache[startKeyframe.id].preparedStartPoints = preparedStartPoints;\n\n        renderCache[endKeyframe.id] = renderCache[endKeyframe.id] || {};\n        renderCache[endKeyframe.id].preparedEndPoints = preparedEndPoints;\n    }\n\n    // Calculate progress between frames as a fraction.\n    const progress =\n        (input.timestamp - startKeyframe.timestamp) /\n        (endKeyframe.timestamp - startKeyframe.timestamp);\n\n    // Keep progress within expected range (ex. division by 0).\n    const clampedProgress = Math.max(0, Math.min(1, progress));\n\n    // Apply timing function of end frame.\n    const adjustedProgress = endKeyframe.timingFunction(clampedProgress);\n\n    return {\n        renderCache,\n        lastFrameId: clampedProgress === 1 ? endKeyframe.id : startKeyframe.id,\n        points: interpolateBetween(adjustedProgress, preparedStartPoints, preparedEndPoints),\n    };\n};\n\nexport const transitionFrames = <T extends Keyframe>(\n    input: TransitionInput<T>,\n): TransitionOutput => {\n    // Erase all old frames.\n    const newInternalFrames: InternalKeyframe[] = [];\n\n    // Reset animation when given no keyframes.\n    if (input.newFrames.length === 0) {\n        return {newFrames: newInternalFrames};\n    }\n\n    // Add current state as initial frame.\n    const currentState = renderFramesAt(input);\n    if (currentState.lastFrameId === null) {\n        // If there is currently no shape being rendered, use a point in the\n        // center of the next frame as the initial point.\n        const firstShape = input.shapeGenerator(input.newFrames[0]);\n        let firstShapeCenterPoint: Point = {\n            x: 0,\n            y: 0,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        };\n        for (const point of firstShape) {\n            firstShapeCenterPoint.x += point.x / firstShape.length;\n            firstShapeCenterPoint.y += point.y / firstShape.length;\n        }\n        currentState.points = [firstShapeCenterPoint, firstShapeCenterPoint, firstShapeCenterPoint];\n    }\n    newInternalFrames.push({\n        id: genId(),\n        initialPoints: currentState.points,\n        timestamp: input.timestamp,\n        timingFunction: timingFunctions.linear,\n        transitionSourceFrameIndex: -1,\n        isSynthetic: true,\n    });\n\n    // Generate and add new frames.\n    let totalOffset = 0;\n    for (let i = 0; i < input.newFrames.length; i++) {\n        const keyframe = input.newFrames[i];\n\n        // Copy previous frame when current one has a delay.\n        if (keyframe.delay) {\n            totalOffset += keyframe.delay;\n            const prevFrame = newInternalFrames[newInternalFrames.length - 1];\n            newInternalFrames.push({\n                id: genId(),\n                initialPoints: prevFrame.initialPoints,\n                timestamp: input.timestamp + totalOffset,\n                timingFunction: timingFunctions.linear,\n                transitionSourceFrameIndex: i - 1,\n                isSynthetic: true,\n            });\n        }\n\n        totalOffset += keyframe.duration;\n        newInternalFrames.push({\n            id: genId(),\n            initialPoints: input.shapeGenerator(keyframe),\n            timestamp: input.timestamp + totalOffset,\n            timingFunction: timingFunctions[keyframe.timingFunction || \"linear\"],\n            transitionSourceFrameIndex: i,\n            isSynthetic: false,\n        });\n    }\n\n    return {newFrames: newInternalFrames};\n};\n","import {Point} from \"../types\";\nimport {RenderCache, InternalKeyframe, renderFramesAt, transitionFrames, Keyframe} from \"./frames\";\n\ninterface CallbackKeyframe extends Keyframe {\n    callback?: () => void;\n}\n\ninterface CallbackStore {\n    [frameId: string]: () => void;\n}\n\nexport const statefulAnimationGenerator =\n    <K extends CallbackKeyframe, T>(\n        generator: (keyframe: K) => Point[],\n        renderer: (points: Point[]) => T,\n        checker: (keyframe: K, index: number) => void,\n    ) =>\n    () => {\n        let internalFrames: InternalKeyframe[] = [];\n        let renderCache: RenderCache = {};\n        let callbackStore: CallbackStore = {};\n\n        // Keep track of paused state.\n        let pausedAt = 0;\n        let pauseOffset = 0;\n        const getAnimationTimestamp = () => Date.now() - pauseOffset;\n        const isPaused = () => pausedAt !== 0;\n\n        const play = () => {\n            if (!isPaused()) return;\n            pauseOffset += getAnimationTimestamp() - pausedAt;\n            pausedAt = 0;\n        };\n\n        const pause = () => {\n            if (isPaused()) return;\n            pausedAt = getAnimationTimestamp();\n        };\n\n        const playPause = () => {\n            ``;\n            if (isPaused()) {\n                play();\n            } else {\n                pause();\n            }\n        };\n\n        const renderFrame = (): T => {\n            const renderOutput = renderFramesAt({\n                renderCache: renderCache,\n                timestamp: isPaused() ? pausedAt : getAnimationTimestamp(),\n                currentFrames: internalFrames,\n            });\n\n            // Update render cache with returned value.\n            renderCache = renderOutput.renderCache;\n\n            // Invoke callback if defined and the first time the frame is reached.\n            if (renderOutput.lastFrameId && callbackStore[renderOutput.lastFrameId]) {\n                callbackStore[renderOutput.lastFrameId]();\n                delete callbackStore[renderOutput.lastFrameId];\n            }\n\n            return renderer(renderOutput.points);\n        };\n\n        const transition = (...keyframes: K[]) => {\n            // Make sure frame info is valid.\n            for (let i = 0; i < keyframes.length; i++) {\n                checker(keyframes[i], i);\n            }\n\n            const transitionOutput = transitionFrames<K>({\n                renderCache: renderCache,\n                timestamp: getAnimationTimestamp(),\n                currentFrames: internalFrames,\n                newFrames: keyframes,\n                shapeGenerator: generator,\n            });\n\n            // Reset internal state..\n            internalFrames = transitionOutput.newFrames;\n            callbackStore = {};\n            renderCache = {};\n\n            // Populate callback store using returned frame ids.\n            for (const newFrame of internalFrames) {\n                if (newFrame.isSynthetic) continue;\n                const {callback} = keyframes[newFrame.transitionSourceFrameIndex];\n                if (callback) callbackStore[newFrame.id] = callback;\n            }\n        };\n\n        return {renderFrame, transition, play, pause, playPause};\n    };\n","import {timingFunctions} from \"./animate/timing\";\n\nconst typeCheck = (name: string, val: any, expected: string[]) => {\n    let actual: string = typeof val;\n    if (actual === \"number\" && isNaN(val)) actual = \"NaN\";\n    if (actual === \"object\" && val === null) actual = \"null\";\n    if (!expected.includes(actual)) {\n        throw `\"${name}\" should have type \"${expected.join(\"|\")}\" but was \"${actual}\".`;\n    }\n};\n\nexport const checkKeyframeOptions = (keyframe: any) => {\n    typeCheck(`keyframe`, keyframe, [\"object\"]);\n    const {delay, duration, timingFunction, callback} = keyframe;\n    typeCheck(`delay`, delay, [\"number\", \"undefined\"]);\n    if (delay && delay < 0) throw `delay is invalid \"${delay}\".`;\n    typeCheck(`duration`, duration, [\"number\"]);\n    if (duration && duration < 0) throw `duration is invalid \"${duration}\".`;\n    typeCheck(`timingFunction`, timingFunction, [\"string\", \"undefined\"]);\n    if (timingFunction && !(timingFunctions as any)[timingFunction])\n        throw `\".timingFunction\" is not recognized \"${timingFunction}\".`;\n    typeCheck(`callback`, callback, [\"function\", \"undefined\"]);\n};\n\nexport const checkBlobOptions = (blobOptions: any) => {\n    typeCheck(`blobOptions`, blobOptions, [\"object\"]);\n    const {seed, extraPoints, randomness, size} = blobOptions;\n    typeCheck(`blobOptions.seed`, seed, [\"string\", \"number\"]);\n    typeCheck(`blobOptions.extraPoints`, extraPoints, [\"number\"]);\n    if (extraPoints < 0) throw `blobOptions.extraPoints is invalid \"${extraPoints}\".`;\n    typeCheck(`blobOptions.randomness`, randomness, [\"number\"]);\n    if (randomness < 0) throw `blobOptions.randomness is invalid \"${randomness}\".`;\n    typeCheck(`blobOptions.size`, size, [\"number\"]);\n    if (size < 0) throw `blobOptions.size is invalid \"${size}\".`;\n};\n\nexport const checkCanvasOptions = (canvasOptions: any) => {\n    typeCheck(`canvasOptions`, canvasOptions, [\"object\", \"undefined\"]);\n    if (canvasOptions) {\n        const {offsetX, offsetY} = canvasOptions;\n        typeCheck(`canvasOptions.offsetX`, offsetX, [\"number\", \"undefined\"]);\n        typeCheck(`canvasOptions.offsetY`, offsetY, [\"number\", \"undefined\"]);\n    }\n};\n\nexport const checkSvgOptions = (svgOptions: any) => {\n    typeCheck(`svgOptions`, svgOptions, [\"object\", \"undefined\"]);\n    if (svgOptions) {\n        const {fill, stroke, strokeWidth} = svgOptions;\n        typeCheck(`svgOptions.fill`, fill, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.stroke`, stroke, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.strokeWidth`, strokeWidth, [\"number\", \"undefined\"]);\n    }\n};\n","import {Point} from \"../internal/types\";\nimport {renderPath2D} from \"../internal/render/canvas\";\nimport {genFromOptions} from \"../internal/gen\";\nimport {mapPoints} from \"../internal/util\";\nimport {statefulAnimationGenerator} from \"../internal/animate/state\";\nimport {checkBlobOptions, checkCanvasOptions, checkKeyframeOptions} from \"../internal/check\";\n\nexport interface CanvasKeyframe {\n    delay?: number;\n    duration: number;\n    timingFunction?:\n        | \"linear\"\n        | \"easeEnd\"\n        | \"easeStart\"\n        | \"ease\"\n        | \"elasticEnd0\"\n        | \"elasticEnd1\"\n        | \"elasticEnd2\"\n        | \"elasticEnd3\";\n    callback?: () => void;\n    blobOptions: {\n        seed: number | string;\n        randomness: number;\n        extraPoints: number;\n        size: number;\n    };\n    canvasOptions?: {\n        offsetX?: number;\n        offsetY?: number;\n    };\n}\n\nconst canvasBlobGenerator = (keyframe: CanvasKeyframe): Point[] => {\n    return mapPoints(genFromOptions(keyframe.blobOptions), ({curr}) => {\n        curr.x += keyframe?.canvasOptions?.offsetX || 0;\n        curr.y += keyframe?.canvasOptions?.offsetY || 0;\n        return curr;\n    });\n};\n\nconst canvasKeyframeChecker = (keyframe: CanvasKeyframe, index: number) => {\n    try {\n        checkBlobOptions(keyframe.blobOptions);\n        checkCanvasOptions(keyframe.canvasOptions);\n        checkKeyframeOptions(keyframe);\n    } catch (e) {\n        throw `(blobs2): keyframe ${index}: ${e}`;\n    }\n};\n\nexport const canvasPath = statefulAnimationGenerator(\n    canvasBlobGenerator,\n    renderPath2D,\n    canvasKeyframeChecker,\n);\n"],"names":["copyPoint","p","x","y","handleIn","handleOut","forPoints","points","callback","i","sibling","pos","mod","length","curr","index","prev","next","mapPoints","out","args","push","coordEqual","a","b","angleOf","dx","dy","angle","Math","atan2","abs","PI","expandHandle","point","handle","cos","sin","collapseHandle","sqrt","aHandle","bHandle","distance","reverse","_a","shift","offset","insertAt","percentage","c","e","cHandle","eHandle","f","splitLine","g","h","dCoord","insertCount","count","d","smooth","strength","n","split","renderPath2D","path","Path2D","moveTo","getNext","currHandle","nextHandle","bezierCurveTo","rand","seed","seedGenerator","str","imul","charCodeAt","xfnv1a","t","genBlob","pointCount","randPointOffset","pointX","pointY","smoothingStrength","tan","genFromOptions","blobOptions","rgen","String","rangeStart","randomness","extraPoints","size","linear","easeEnd","easeStart","ease","elasticEnd","s","pow","timingFunctions","elasticEnd0","elasticEnd1","elasticEnd2","elasticEnd3","optimizeOrder","setMinOffset","total","j","minTotal","minOffset","minOffsetBase","Infinity","divide","Error","slice","lengths","divisors","divideLengths","pop","last","fixAnglesWith","fixee","fixer","fixAnglesSelf","add","map","sizes","maxSizeIndex","prepare","options","divideRatio","max","aNorm","bNorm","bOpt","rawAngles","interpolateAngle","tau","interpolateBetween","clamped","min","genId","random","substr","renderFramesAt","input","renderCache","currentFrames","lastFrameId","first","id","initialPoints","startKeyframe","endKeyframe","timestamp","endKeyframeIsLast","preparedStartPoints","preparedEndPoints","progress","clampedProgress","adjustedProgress","timingFunction","transitionFrames","newInternalFrames","newFrames","currentState","firstShape","shapeGenerator","firstShapeCenterPoint","firstShape_1","_i","transitionSourceFrameIndex","isSynthetic","totalOffset","prevFrame","keyframe","delay","duration","statefulAnimationGenerator","generator","renderer","checker","getAnimationTimestamp","Date","now","pauseOffset","isPaused","pausedAt","play","pause","internalFrames","callbackStore","renderFrame","renderOutput","transition","keyframes","transitionOutput","internalFrames_1","newFrame","playPause","typeCheck","name","val","expected","actual","isNaN","includes","join","checkKeyframeOptions","checkBlobOptions","checkCanvasOptions","canvasOptions","offsetX","offsetY","canvasBlobGenerator","canvasKeyframeChecker","canvasPath"],"mappings":"qaAEO,IAAMA,UAAY,SAACC,GAAoB,OAC1CC,EAAGD,EAAEC,EACLC,EAAGF,EAAEE,EACLC,qBAAcH,EAAEG,UAChBC,sBAAeJ,EAAEI,aAmBRC,UAAY,SAACC,EAAiBC,cAC9BC,GACW,SAAVC,EAAWC,GAAgB,OAAAX,UAAUO,EAAOK,IAAID,EAAKJ,EAAOM,UAClEL,EAAS,CACLM,KAAMd,UAAUO,EAAOE,IACvBM,MAAON,EACPC,UACAM,KAAM,WAAM,OAAAN,EAAQD,EAAI,IACxBQ,KAAM,WAAM,OAAAP,EAAQD,EAAI,MAPhC,QAASA,EAAI,EAAGA,EAAIF,EAAOM,OAAQJ,MAA1BA,IAYAS,UAAY,SACrBX,EACAC,GAEA,IAAMW,EAAe,GAIrB,OAHAb,UAAUC,EAAQ,SAACa,GACfD,EAAIE,KAAKb,EAASY,MAEfD,GAGEG,WAAa,SAACC,EAAUC,GACjC,OAAOD,EAAErB,IAAMsB,EAAEtB,GAAKqB,EAAEpB,IAAMqB,EAAErB,GAGvBsB,QAAU,SAACF,EAAUC,GAC9B,IAAME,EAAKF,EAAEtB,EAAIqB,EAAErB,EACbyB,GAAMH,EAAErB,EAAIoB,EAAEpB,EACdyB,EAAQC,KAAKC,MAAMH,EAAID,GAC7B,OAAIE,EAAQ,EACDC,KAAKE,IAAIH,GAET,EAAIC,KAAKG,GAAKJ,GAIhBK,aAAe,SAACC,EAAcC,GAA0B,OACjEjC,EAAGgC,EAAMhC,EAAIiC,EAAOtB,OAASgB,KAAKO,IAAID,EAAOP,OAC7CzB,EAAG+B,EAAM/B,EAAIgC,EAAOtB,OAASgB,KAAKQ,IAAIF,EAAOP,SAG3CU,eAAiB,SAACJ,EAAcC,GAA0B,OAC5DP,MAAOH,QAAQS,EAAOC,GACtBtB,OAAQgB,KAAKU,KAAKV,SAACM,EAAOjC,EAAIgC,EAAMhC,EAAM,GAAI2B,SAACM,EAAOhC,EAAI+B,EAAM/B,EAAM,MAG7DU,OAAS,SAACU,EAAUC,GAC7B,IAAMgB,EAAUP,aAAaV,EAAGA,EAAElB,WAC5BoC,EAAUR,aAAaT,EAAGA,EAAEpB,UAGlC,OAFWsC,SAASnB,EAAGC,GACNkB,SAASF,EAASC,GACXlB,EAAElB,UAAUQ,OAASW,EAAEpB,SAASS,QAAU,GAGzD8B,QAAU,SAACpC,GACpB,OAAOW,UAAUX,EAAQ,SAACqC,OAAC7B,UACjBmB,GAAQxB,aAAQH,EAAOM,OAASE,EAAQ,GAG9C,OAFAmB,EAAM9B,SAASwB,OAASC,KAAKG,GAC7BE,EAAM7B,UAAUuB,OAASC,KAAKG,GACvBE,KAIFW,MAAQ,SAACC,EAAgBvC,GAClC,OAAOW,UAAUX,EAAQ,SAACqC,OAAC7B,UACvB,OAAOL,aAAQK,EAAQ+B,MAclBC,SAAW,SAACC,EAAoBzB,EAAUC,GACnD,IAAMyB,EAAIjD,UAAUuB,GACpB0B,EAAE5C,UAAUQ,QAAUmC,EAEtB,IAAME,EAAIlD,UAAUwB,GACpB0B,EAAE9C,SAASS,QAAU,EAAImC,EAEzB,IAAMR,EAAUP,aAAaV,EAAGA,EAAElB,WAC5BoC,EAAUR,aAAaT,EAAGA,EAAEpB,UAC5B+C,EAAUlB,aAAagB,EAAGA,EAAE5C,WAC5B+C,EAAUnB,aAAaiB,EAAGA,EAAE9C,UAC5BiD,EAAIC,UAAUN,EAAYR,EAASC,GACnCc,EAAID,UAAUN,EAAYG,EAASE,GACnCG,EAAIF,UAAU,EAAIN,EAAYI,EAASC,GACvCI,EAASH,UAAUN,EAAYO,EAAGC,GAQxC,MAAO,CAACP,EANS,CACb/C,EAAGuD,EAAOvD,EACVC,EAAGsD,EAAOtD,EACVC,SAAUkC,eAAemB,EAAQF,GACjClD,UAAWiC,eAAemB,EAAQD,IAExBN,IAGLQ,YAAc,SAACC,EAAepC,EAAUC,GACjD,GAAImC,EAAQ,EAAG,MAAO,CAACpC,EAAGC,GAC1B,IACMoB,EAAYG,SADC,EAAIY,EACgBpC,EAAGC,GAAnCyB,OAAGW,OAAGV,OACb,OAAc,IAAVS,EAAoB,CAACV,EAAGW,EAAGV,mBACvBD,GAAMS,YAAYC,EAAQ,EAAGC,EAAGV,KAK/BW,OAAS,SAACtD,EAAiBuD,GACpC,OAAO5C,UAAUX,EAAQ,SAACqC,OAAC9B,SAAMG,SAAMD,SAC7BY,EAAQH,QAAQT,IAAQC,KAC9B,MAAO,CACHf,EAAGY,EAAKZ,EACRC,EAAGW,EAAKX,EACRC,SAAU,CACNwB,MAAOA,EAAQC,KAAKG,GACpBnB,OAAQiD,EAAWpB,SAAS5B,EAAME,MAEtCX,UAAW,CACPuB,QACAf,OAAQiD,EAAWpB,SAAS5B,EAAMG,UAQrCL,IAAM,SAACW,EAAWwC,GAC3B,OAASxC,EAAIwC,EAAKA,GAAKA,GAcdrB,SAAW,SAACnB,EAAUC,GAC/B,OAAOK,KAAKU,KAAKV,SAACN,EAAErB,EAAIsB,EAAEtB,EAAM,GAAI2B,SAACN,EAAEpB,EAAIqB,EAAErB,EAAM,KAQ1C6D,MAAQ,SAAChB,EAAoBzB,EAAWC,GACjD,OAAOD,EAAIyB,GAAcxB,EAAID,IAGpB+B,UAAY,SAACN,EAAoBzB,EAAUC,GACpD,MAAO,CACHtB,EAAG8D,MAAMhB,EAAYzB,EAAErB,EAAGsB,EAAEtB,GAC5BC,EAAG6D,MAAMhB,EAAYzB,EAAEpB,EAAGqB,EAAErB,KC3IvB8D,aAAe,SAAC1D,GACzB,IAAM2D,EAAO,IAAIC,OAEjB,OAAI5D,EAAOM,OAAS,IACpBqD,EAAKE,OAAO7D,EAAO,GAAGL,EAAGK,EAAO,GAAGJ,GAEnCG,UAAUC,EAAQ,SAACqC,OAAC9B,SACVG,GAAOoD,YACPC,EAAarC,aAAanB,EAAMA,EAAKT,WACrCkE,EAAatC,aAAahB,EAAMA,EAAKb,UAC3C8D,EAAKM,cAAcF,EAAWpE,EAAGoE,EAAWnE,EAAGoE,EAAWrE,EAAGqE,EAAWpE,EAAGc,EAAKf,EAAGe,EAAKd,MAP9D+D,GCvDrBO,KAAO,SAACC,GACjB,IAcenD,EAAWC,EAAWyB,EAAWW,EAe1Ce,EA7BS,SAACC,GAEZ,IADA,IAAIpB,EAAI,WACC/C,EAAI,EAAGA,EAAImE,EAAI/D,OAAQJ,IAC5B+C,EAAI3B,KAAKgD,KAAKrB,EAAIoB,EAAIE,WAAWrE,GAAI,UAEzC,OAAO,WAKH,OAJA+C,GAAKA,GAAK,GACVA,GAAKA,IAAM,EACXA,GAAKA,GAAK,EACVA,GAAKA,IAAM,IACHA,GAAKA,GAAK,KAAO,GAmBXuB,CAAOL,GAC7B,OAhBenD,EAgBFoD,IAhBanD,EAgBImD,IAhBO1B,EAgBU0B,IAhBCf,EAgBgBe,IAhBF,WAK1D,IAAIK,GAJJzD,KAAO,IACPC,KAAO,GAGW,EAOlB,OANAD,EAAIC,EAAKA,IAAM,EACfA,GAJAyB,KAAO,IAIGA,GAAK,GAAM,EAIrBA,GAHAA,EAAKA,GAAK,GAAOA,IAAM,KAEvB+B,EAAKA,GADLpB,GALAA,KAAO,GAKE,EAAK,GACA,GACA,GACNoB,IAAM,GAAK,aCvBdC,QAAU,SAACC,EAAoBpC,GAIxC,IAHA,IAAMlB,EAAmB,EAAVC,KAAKG,GAAUkD,EAExB3E,EAAkB,GACfE,EAAI,EAAGA,EAAIyE,EAAYzE,IAAK,CACjC,IAAM0E,EAAkBrC,IAClBsC,EAASvD,KAAKQ,IAAI5B,EAAImB,GACtByD,EAASxD,KAAKO,IAAI3B,EAAImB,GAC5BrB,EAAOc,KAAK,CACRnB,EAAG,GAAMkF,EAASD,EAClBhF,EAAG,GAAMkF,EAASF,EAClB/E,SAAU,CAACwB,MAAO,EAAGf,OAAQ,GAC7BR,UAAW,CAACuB,MAAO,EAAGf,OAAQ,KAKtC,IAAMyE,EAAsB,EAAI,EAAKzD,KAAK0D,IAAI3D,EAAQ,GAAMC,KAAKQ,IAAIT,EAAQ,GAAK,EAElF,OAAOiC,OAAOtD,EAAQ+E,IAGbE,eAAiB,SAACC,GAC3B,IAAMC,EAAOjB,KAAKkB,OAAOF,EAAYf,OAU/BkB,EAAa,GAAK,EAAIH,EAAYI,WAAa,IAE/CtF,EAAS0E,QACX,EAAIQ,EAAYK,YAChB,WAAM,OAACF,EAAaF,KAAU,EAAIE,IAAe,IAG/CG,EAAON,EAAYM,KACzB,OAAO7E,UAAUX,EAAQ,SAACqC,GAAC9B,SAKvB,OAJAA,EAAKZ,GAAK6F,EACVjF,EAAKX,GAAK4F,EACVjF,EAAKV,SAASS,QAAUkF,EACxBjF,EAAKT,UAAUQ,QAAUkF,EAClBjF,KChDTkF,OAAqB,SAAC/F,GACxB,OAAOA,GAGLgG,QAAsB,SAAChG,GACzB,OAAO,EAAI4B,SAAC5B,EAAI,EAAM,IAGpBiG,UAAwB,SAACjG,GAC3B,OAAO,EAAIgG,QAAQ,EAAIhG,IAGrBkG,KAAmB,SAAClG,GACtB,MAAO,GAAM,GAAM4B,KAAKQ,IAAIR,KAAKG,IAAM/B,EAAI,OAGzCmG,WACF,SAACC,GACD,OAAA,SAACpG,GACG,OAAO4B,KAAKyE,IAAI,GAAI,GAAKrG,GAAK4B,KAAKQ,KAAMpC,EAAIoG,EAAI,IAAM,EAAIxE,KAAKG,IAAOqE,GAAK,IAIvEE,gBAAkB,CAC3BP,cACAC,gBACAC,oBACAC,UACAK,YAAaJ,WAAW,GACxBK,YAAaL,WAAW,KACxBM,YAAaN,WAAW,KACxBO,YAAaP,WAAW,MCrBtBQ,cAAgB,SAACrF,EAAYC,GAOV,SAAfqF,EAAgBtG,GAClB,IAAK,IAAIE,EAAI,EAAGA,EAAIkD,EAAOlD,IAAK,CAE5B,IADA,IAAIqG,EAAQ,EACHC,EAAI,EAAGA,EAAIpD,IAChBmD,GAASjF,SAAC,IAAMa,SAASnB,EAAEwF,GAAIxG,EAAOK,IAAImG,EAAItG,EAAGkD,KAAa,KAClDqD,EAARF,IAFmBC,KAIvBD,GAASE,IACTA,EAAWF,EACXG,EAAYxG,EACZyG,EAAgB3G,IAhB5B,IAAMoD,EAAQpC,EAAEV,OAEZmG,EAAWG,EAAAA,EACXF,EAAY,EACZC,EAAyB,GAmB7B,OAHAL,EAAarF,GACbqF,EAAalE,QAAQnB,IAEdqB,MAAMoE,EAAWC,IAGfE,OAAS,SAACzD,EAAepD,GAClC,GAAIA,EAAOM,OAAS,EAAG,MAAM,IAAIwG,MAAM,qBACvC,GAAI1D,EAAQpD,EAAOM,OAAQ,MAAM,IAAIwG,MAAM,wBAC3C,GAAI1D,IAAUpD,EAAOM,OAAQ,OAAON,EAAO+G,QAE3C,IAAMC,EAAoB,GAC1BjH,UAAUC,EAAQ,SAACqC,OAAC9B,SAAMG,SACtBsG,EAAQlG,KAAKR,OAAOC,EAAMG,QAK9B,IAFA,IAAMuG,EAAWC,cAAcF,EAAS5D,EAAQpD,EAAOM,QACjDM,EAAe,GACZV,EAAI,EAAGA,EAAIF,EAAOM,OAAQJ,IAAK,CACpC,IAAMK,EAAcK,EAAIA,EAAIN,OAAS,IAAMN,EAAOE,GAC5CQ,EAAOV,EAAOK,IAAIH,EAAI,EAAGF,EAAOM,SACtCM,EAAIuG,MACJvG,EAAIE,WAAJF,EAAYuC,YAAY8D,EAAS/G,GAAIK,EAAMG,IAEzC0G,EAAOxG,EAAIuG,MAGjB,OAFAvG,EAAI,GAAGf,SAAWuH,EAAMvH,SAEjBe,GAOLyG,cAAgB,SAACC,EAAgBC,GACnC,OAAO5G,UAAU2G,EAAO,SAACjF,OAAC7B,UAAOD,SAAME,SAAMC,SAOzC,OAN6B,IAAzBH,EAAKV,SAASS,QAAgBS,WAAWN,IAAQF,KACjDA,EAAKV,SAASwB,MAAQkG,EAAM/G,GAAOX,SAASwB,OAElB,IAA1Bd,EAAKT,UAAUQ,QAAgBS,WAAWL,IAAQH,KAClDA,EAAKT,UAAUuB,MAAQkG,EAAM/G,GAAOV,UAAUuB,OAE3Cd,KAKTiH,cAAgB,SAACxH,GACnB,OAAOW,UAAUX,EAAQ,SAACqC,OAAC9B,SAAME,SAAMC,SAC7BW,EAAQH,QAAQT,IAAQC,KAO9B,OAN6B,IAAzBH,EAAKV,SAASS,SACdC,EAAKV,SAASwB,MAAQA,EAAQC,KAAKG,IAET,IAA1BlB,EAAKT,UAAUQ,SACfC,EAAKT,UAAUuB,MAAQA,GAEpBd,KAIT2G,cAAgB,SAACF,EAAmBS,GAGtC,IAFA,IAAMR,EAAWD,EAAQU,IAAI,WAAM,OAAA,IAC7BC,EAAQX,EAAQD,QACb7G,EAAI,EAAGA,EAAIuH,EAAKvH,IAAK,CAE1B,IADA,IAAI0H,EAAe,EACVpB,EAAI,EAAGA,EAAImB,EAAMrH,OAAQkG,KAC1BmB,EAAMnB,GAAKmB,EAAMC,IAIjBD,EAAMnB,KAAOmB,EAAMC,IACfZ,EAAQR,GAAKQ,EAAQY,MAJzBA,EAAepB,GASvBS,EAASW,KACTD,EAAMC,GAAgBZ,EAAQY,GAAgBX,EAASW,GAE3D,OAAOX,GAGEY,QAAU,SACnB7G,EACAC,EACA6G,GAEA,IAAMnD,EAAamD,EAAQC,YAAczG,KAAK0G,IAAIhH,EAAEV,OAAQW,EAAEX,QACxD2H,EAAQpB,OAAOlC,EAAY3D,GAC3BkH,EAAQrB,OAAOlC,EAAY1D,GAC3BkH,EAAO9B,cAAc4B,EAAOC,GAClC,MAAO,CACHJ,EAAQM,UAAYH,EAAQZ,cAAcG,cAAcS,GAAQE,GAChEL,EAAQM,UAAYD,EAAOd,cAAcG,cAAcW,GAAOF,KC3HhEI,iBAAmB,SAAC5F,EAAoBzB,EAAWC,GACrD,IAAMqH,EAAgB,EAAVhH,KAAKG,GACbwG,EAAQ5H,IAAIW,EAAGsH,GACfJ,EAAQ7H,IAAIY,EAAGqH,GAQnB,OAPIhH,KAAKE,IAAIyG,EAAQC,GAAS5G,KAAKG,KAC3BwG,EAAQC,EACRD,GAASK,EAETJ,GAASI,GAGV7E,MAAMhB,EAAYwF,EAAOC,IAMvBK,mBAAqB,SAAC9F,EAAoBzB,EAAYC,GAC/D,GAAID,EAAEV,SAAWW,EAAEX,OAAQ,MAAM,IAAIwG,MAAM,oCAO3C,IAHA,IAAM0B,EAAUlH,KAAKmH,IAAI,EAAGnH,KAAK0G,IAAI,EAAGvF,IAElCzC,EAAkB,GACfE,EAAI,EAAGA,EAAIc,EAAEV,OAAQJ,IAC1BF,EAAOc,0BACAiC,UAAUN,EAAYzB,EAAEd,GAAIe,EAAEf,MACjCL,SAAU,CACNwB,MAAOgH,iBAAiB5F,EAAYzB,EAAEd,GAAGL,SAASwB,MAAOJ,EAAEf,GAAGL,SAASwB,OACvEf,OAAQmD,MAAM+E,EAASxH,EAAEd,GAAGL,SAASS,OAAQW,EAAEf,GAAGL,SAASS,SAE/DR,UAAW,CACPuB,MAAOgH,iBAAiB5F,EAAYzB,EAAEd,GAAGJ,UAAUuB,MAAOJ,EAAEf,GAAGJ,UAAUuB,OACzEf,OAAQmD,MAAM+E,EAASxH,EAAEd,GAAGJ,UAAUQ,OAAQW,EAAEf,GAAGJ,UAAUQ,YAIzE,OAAON,GCKL0I,MAAQ,WACV,OAAOtD,OAAO9D,KAAKqH,UAAUC,OAAO,IAG3BC,eAAiB,SAACC,OACpBC,EAA8BD,cAAjBE,EAAiBF,gBAErC,GAA6B,IAAzBE,EAAc1I,OACd,MAAO,CAACyI,cAAaE,YAAa,KAAMjJ,OAAQ,IAIpD,GAA6B,IAAzBgJ,EAAc1I,OAAc,CAC5B,IAAM4I,EAAQF,EAAc,GAC5B,MAAO,CAACD,cAAaE,YAAaC,EAAMC,GAAInJ,OAAQkJ,EAAME,eAM9D,IAFA,IAAIC,EAAgBL,EAAc,GAC9BM,EAAcN,EAAc,GACvB9I,EAAI,EAAGA,EAAI8I,EAAc1I,UAC1BgJ,EAAYC,UAAYT,EAAMS,WADIrJ,IAEtCmJ,EAAgBL,EAAc9I,EAAI,GAClCoJ,EAAcN,EAAc9I,GAIhC,IAAMsJ,EAAoBF,IAAgBN,EAAcA,EAAc1I,OAAS,GAE/E,GADmCgJ,EAAYC,UAAYT,EAAMS,WAC/BC,EAC9B,MAAO,CACHT,cACAE,YAAaK,EAAYH,GACzBnJ,OAAQsJ,EAAYF,eAK5B,IAAIK,YACAV,EAAYM,EAAcF,0BAAKM,oBAC/BC,YAAyCX,EAAYO,EAAYH,0BAAKO,kBACrED,GAAwBC,IACxBD,GAADpH,EAA2CwF,QACvCwB,EAAcD,cACdE,EAAYF,cACZ,CAAChB,WAAW,EAAOL,YAAa,QAHd2B,OAMtBX,EAAYM,EAAcF,IAAMJ,EAAYM,EAAcF,KAAO,GACjEJ,EAAYM,EAAcF,IAAIM,oBAAsBA,EAEpDV,EAAYO,EAAYH,IAAMJ,EAAYO,EAAYH,KAAO,GAC7DJ,EAAYO,EAAYH,IAAIO,kBAAoBA,GAIpD,IAAMC,GACDb,EAAMS,UAAYF,EAAcE,YAChCD,EAAYC,UAAYF,EAAcE,WAGrCK,EAAkBtI,KAAK0G,IAAI,EAAG1G,KAAKmH,IAAI,EAAGkB,IAG1CE,EAAmBP,EAAYQ,eAAeF,GAEpD,MAAO,CACHb,cACAE,aAAiC,IAApBW,EAAwBN,EAAiBD,GAALF,GACjDnJ,OAAQuI,mBAAmBsB,EAAkBJ,EAAqBC,KAI7DK,iBAAmB,SAC5BjB,GAGA,IAAMkB,EAAwC,GAG9C,GAA+B,IAA3BlB,EAAMmB,UAAU3J,OAChB,MAAO,CAAC2J,UAAWD,GAIvB,IAAME,EAAerB,eAAeC,GACpC,GAAiC,OAA7BoB,EAAajB,YAAsB,CAUnC,IAPA,IAAMkB,EAAarB,EAAMsB,eAAetB,EAAMmB,UAAU,IACpDI,EAA+B,CAC/B1K,EAAG,EACHC,EAAG,EACHC,SAAU,CAACwB,MAAO,EAAGf,OAAQ,GAC7BR,UAAW,CAACuB,MAAO,EAAGf,OAAQ,QAEdgK,IAAAC,WAAAA,IAAY,CAA3B,IAAM5I,OACP0I,EAAsB1K,GAAKgC,EAAMhC,EAAIwK,EAAW7J,OAChD+J,EAAsBzK,GAAK+B,EAAM/B,EAAIuK,EAAW7J,OAEpD4J,EAAalK,OAAS,CAACqK,EAAuBA,EAAuBA,GAEzEL,EAAkBlJ,KAAK,CACnBqI,GAAIT,QACJU,cAAec,EAAalK,OAC5BuJ,UAAWT,EAAMS,UACjBO,eAAgB9D,gBAAgBP,OAChC+E,4BAA6B,EAC7BC,aAAa,IAKjB,IADA,IAAIC,EAAc,EACTxK,EAAI,EAAGA,EAAI4I,EAAMmB,UAAU3J,OAAQJ,IAAK,CAC7C,IAKUyK,EALJC,EAAW9B,EAAMmB,UAAU/J,GAG7B0K,EAASC,QACTH,GAAeE,EAASC,MAClBF,EAAYX,EAAkBA,EAAkB1J,OAAS,GAC/D0J,EAAkBlJ,KAAK,CACnBqI,GAAIT,QACJU,cAAeuB,EAAUvB,cACzBG,UAAWT,EAAMS,UAAYmB,EAC7BZ,eAAgB9D,gBAAgBP,OAChC+E,2BAA4BtK,EAAI,EAChCuK,aAAa,KAIrBC,GAAeE,EAASE,SACxBd,EAAkBlJ,KAAK,CACnBqI,GAAIT,QACJU,cAAeN,EAAMsB,eAAeQ,GACpCrB,UAAWT,EAAMS,UAAYmB,EAC7BZ,eAAgB9D,gBAAgB4E,EAASd,gBAAkB,UAC3DU,2BAA4BtK,EAC5BuK,aAAa,IAIrB,MAAO,CAACR,UAAWD,IClLVe,2BACT,SACIC,EACAC,EACAC,GAEJ,OAAA,WAQkC,SAAxBC,IAA8B,OAAAC,KAAKC,MAAQC,EAChC,SAAXC,IAAiB,OAAa,IAAbC,EAEV,SAAPC,IACGF,MACLD,GAAeH,IAA0BK,EACzCA,EAAW,GAGD,SAARE,IACEH,MACJC,EAAWL,KAlBf,IAAIQ,EAAqC,GACrC5C,EAA2B,GAC3B6C,EAA+B,GAG/BJ,EAAW,EACXF,EAAc,EAsElB,MAAO,CAACO,YA9CY,WAChB,IAAMC,EAAejD,eAAe,CAChCE,YAAaA,EACbQ,UAAWgC,IAAaC,EAAWL,IACnCnC,cAAe2C,IAYnB,OARA5C,EAAc+C,EAAa/C,YAGvB+C,EAAa7C,aAAe2C,EAAcE,EAAa7C,eACvD2C,EAAcE,EAAa7C,sBACpB2C,EAAcE,EAAa7C,cAG/BgC,EAASa,EAAa9L,SA8BZ+L,WA3BF,eAAC,aAAAxB,mBAAAA,IAAAyB,kBAEhB,IAAK,IAAI9L,EAAI,EAAGA,EAAI8L,EAAU1L,OAAQJ,IAClCgL,EAAQc,EAAU9L,GAAIA,GAG1B,IAAM+L,EAAmBlC,iBAAoB,CACzChB,YAAaA,EACbQ,UAAW4B,IACXnC,cAAe2C,EACf1B,UAAW+B,EACX5B,eAAgBY,IAIpBW,EAAiBM,EAAiBhC,UAClC2B,EAAgB,GAChB7C,EAAc,GAGd,IAAuB,QAAAmD,IAAA7J,WAAAA,IAAgB,CAAlC,IAEMpC,EAFAkM,OACHA,EAAS1B,cACNxK,EAAY+L,EAAUG,EAAS3B,wCACxBoB,EAAcO,EAAShD,IAAMlJ,KAIlBwL,OAAMC,QAAOU,UAvD5B,YAEVb,IACAE,EAEAC,SC1CVW,UAAY,SAACC,EAAcC,EAAUC,GACvC,IAAIC,SAAwBF,EAG5B,GAFe,WAAXE,GAAuBC,MAAMH,KAAME,EAAS,QAE3CD,EAASG,SAD2BF,EAA1B,WAAXA,GAA+B,OAARF,EAAuB,OAC3BE,GACnB,KAAM,IAAIH,yBAA2BE,EAASI,KAAK,mBAAkBH,QAIhEI,qBAAuB,SAACjC,GACjCyB,UAAU,WAAYzB,EAAU,CAAC,WAC1B,IAAAC,EAA6CD,QAAtCE,EAAsCF,WAA5Bd,EAA4Bc,iBAAZ3K,EAAY2K,WAEpD,GADAyB,UAAU,QAASxB,EAAO,CAAC,SAAU,cACjCA,GAASA,EAAQ,EAAG,KAAM,qBAAqBA,OAEnD,GADAwB,UAAU,WAAYvB,EAAU,CAAC,WAC7BA,GAAYA,EAAW,EAAG,KAAM,wBAAwBA,OAE5D,GADAuB,UAAU,iBAAkBvC,EAAgB,CAAC,SAAU,cACnDA,IAAoB9D,gBAAwB8D,GAC5C,KAAM,wCAAwCA,OAClDuC,UAAU,WAAYpM,EAAU,CAAC,WAAY,eAGpC6M,iBAAmB,SAAC5H,GAC7BmH,UAAU,cAAenH,EAAa,CAAC,WAChC,IAAAf,EAAuCe,OAAjCK,EAAiCL,cAApBI,EAAoBJ,aAARM,EAAQN,OAG9C,GAFAmH,UAAU,mBAAoBlI,EAAM,CAAC,SAAU,WAC/CkI,UAAU,0BAA2B9G,EAAa,CAAC,WAC/CA,EAAc,EAAG,KAAM,uCAAuCA,OAElE,GADA8G,UAAU,yBAA0B/G,EAAY,CAAC,WAC7CA,EAAa,EAAG,KAAM,sCAAsCA,OAEhE,GADA+G,UAAU,mBAAoB7G,EAAM,CAAC,WACjCA,EAAO,EAAG,KAAM,gCAAgCA,QAG3CuH,mBAAqB,SAACC,GAE/B,IACWC,EAFXZ,UAAU,gBAAiBW,EAAe,CAAC,SAAU,cACjDA,IACOC,EAAoBD,UAAXE,EAAWF,UAC3BX,UAAU,wBAAyBY,EAAS,CAAC,SAAU,cACvDZ,UAAU,wBAAyBa,EAAS,CAAC,SAAU,gBCTzDC,oBAAsB,SAACvC,GACzB,OAAOjK,UAAUsE,eAAe2F,EAAS1F,aAAc,SAAC7C,OAAC9B,SAGrD,OAFAA,EAAKZ,cAAKiL,MAAAA,SAAAA,EAAUoC,oCAAeC,UAAW,EAC9C1M,EAAKX,cAAKgL,MAAAA,SAAAA,EAAUoC,oCAAeE,UAAW,EACvC3M,KAIT6M,sBAAwB,SAACxC,EAA0BpK,GACrD,IACIsM,iBAAiBlC,EAAS1F,aAC1B6H,mBAAmBnC,EAASoC,eAC5BH,qBAAqBjC,GACvB,MAAOjI,GACL,KAAM,sBAAsBnC,OAAUmC,IAIjC0K,WAAatC,2BACtBoC,oBACAzJ,aACA0J"}
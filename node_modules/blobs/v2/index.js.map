{"version":3,"file":"index.js","sources":["../internal/util.ts","../internal/gen.ts","../internal/rand.ts","../internal/check.ts","../public/blobs.ts","../internal/render/svg.ts","../internal/render/canvas.ts"],"sourcesContent":["import {Coord, Handle, Point} from \"./types\";\n\nexport const copyPoint = (p: Point): Point => ({\n    x: p.x,\n    y: p.y,\n    handleIn: {...p.handleIn},\n    handleOut: {...p.handleOut},\n});\n\nexport interface PointIteratorArgs {\n    curr: Point;\n    index: number;\n    sibling: (pos: number) => Point;\n    prev: () => Point;\n    next: () => Point;\n}\n\nexport const coordPoint = (coord: Coord): Point => {\n    return {\n        ...coord,\n        handleIn: {angle: 0, length: 0},\n        handleOut: {angle: 0, length: 0},\n    };\n};\n\nexport const forPoints = (points: Point[], callback: (args: PointIteratorArgs) => void) => {\n    for (let i = 0; i < points.length; i++) {\n        const sibling = (pos: number) => copyPoint(points[mod(pos, points.length)]);\n        callback({\n            curr: copyPoint(points[i]),\n            index: i,\n            sibling,\n            prev: () => sibling(i - 1),\n            next: () => sibling(i + 1),\n        });\n    }\n};\n\nexport const mapPoints = (\n    points: Point[],\n    callback: (args: PointIteratorArgs) => Point,\n): Point[] => {\n    const out: Point[] = [];\n    forPoints(points, (args) => {\n        out.push(callback(args));\n    });\n    return out;\n};\n\nexport const coordEqual = (a: Coord, b: Coord): boolean => {\n    return a.x === b.x && a.y === b.y;\n};\n\nexport const angleOf = (a: Coord, b: Coord): number => {\n    const dx = b.x - a.x;\n    const dy = -b.y + a.y;\n    const angle = Math.atan2(dy, dx);\n    if (angle < 0) {\n        return Math.abs(angle);\n    } else {\n        return 2 * Math.PI - angle;\n    }\n};\n\nexport const expandHandle = (point: Coord, handle: Handle): Coord => ({\n    x: point.x + handle.length * Math.cos(handle.angle),\n    y: point.y + handle.length * Math.sin(handle.angle),\n});\n\nconst collapseHandle = (point: Coord, handle: Coord): Handle => ({\n    angle: angleOf(point, handle),\n    length: Math.sqrt((handle.x - point.x) ** 2 + (handle.y - point.y) ** 2),\n});\n\nexport const length = (a: Point, b: Point): number => {\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const ab = distance(a, b);\n    const abHandle = distance(aHandle, bHandle);\n    return (ab + abHandle + a.handleOut.length + b.handleIn.length) / 2;\n};\n\nexport const reverse = (points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        const point = sibling(points.length - index - 1);\n        point.handleIn.angle += Math.PI;\n        point.handleOut.angle += Math.PI;\n        return point;\n    });\n};\n\nexport const shift = (offset: number, points: Point[]): Point[] => {\n    return mapPoints(points, ({index, sibling}) => {\n        return sibling(index + offset);\n    });\n};\n\n// Add a control point to the curve between a and b.\n// Percentage [0, 1] from a to b.\n// a: original first point.\n// b: original last point.\n// c: new first point.\n// d: new added point.\n// e: new last point.\n// f: split point between a and b's handles.\n// g: split point between c's handle and f.\n// h: split point between e's handle and f.\nexport const insertAt = (percentage: number, a: Point, b: Point): [Point, Point, Point] => {\n    const c = copyPoint(a);\n    c.handleOut.length *= percentage;\n\n    const e = copyPoint(b);\n    e.handleIn.length *= 1 - percentage;\n\n    const aHandle = expandHandle(a, a.handleOut);\n    const bHandle = expandHandle(b, b.handleIn);\n    const cHandle = expandHandle(c, c.handleOut);\n    const eHandle = expandHandle(e, e.handleIn);\n    const f = splitLine(percentage, aHandle, bHandle);\n    const g = splitLine(percentage, cHandle, f);\n    const h = splitLine(1 - percentage, eHandle, f);\n    const dCoord = splitLine(percentage, g, h);\n\n    const d: Point = {\n        x: dCoord.x,\n        y: dCoord.y,\n        handleIn: collapseHandle(dCoord, g),\n        handleOut: collapseHandle(dCoord, h),\n    };\n    return [c, d, e];\n};\n\nexport const insertCount = (count: number, a: Point, b: Point): Point[] => {\n    if (count < 2) return [a, b];\n    const percentage = 1 / count;\n    const [c, d, e] = insertAt(percentage, a, b);\n    if (count === 2) return [c, d, e];\n    return [c, ...insertCount(count - 1, d, e)];\n};\n\n// Smooths out the path made up of the given points.\n// Existing handles are ignored.\nexport const smooth = (points: Point[], strength: number): Point[] => {\n    return mapPoints(points, ({curr, next, prev}) => {\n        const angle = angleOf(prev(), next());\n        return {\n            x: curr.x,\n            y: curr.y,\n            handleIn: {\n                angle: angle + Math.PI,\n                length: strength * distance(curr, prev()),\n            },\n            handleOut: {\n                angle,\n                length: strength * distance(curr, next()),\n            },\n        };\n    });\n};\n\n// Modulo operation that always produces a positive result.\n// https://stackoverflow.com/q/4467539/3053361\nexport const mod = (a: number, n: number): number => {\n    return ((a % n) + n) % n;\n};\n\n// Converts degrees to radians.\nexport const rad = (deg: number) => {\n    return (deg / 360) * 2 * Math.PI;\n};\n\n// Converts radians to degrees.\nexport const deg = (rad: number) => {\n    return (((rad / Math.PI) * 1) / 2) * 360;\n};\n\n// Calculates distance between two points.\nexport const distance = (a: Coord, b: Coord): number => {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n};\n\n// Calculates the angle of the line from a to b in degrees.\nexport const angle = (a: Coord, b: Coord): number => {\n    return deg(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nexport const split = (percentage: number, a: number, b: number): number => {\n    return a + percentage * (b - a);\n};\n\nexport const splitLine = (percentage: number, a: Coord, b: Coord): Coord => {\n    return {\n        x: split(percentage, a.x, b.x),\n        y: split(percentage, a.y, b.y),\n    };\n};\n","import {rand} from \"../internal/rand\";\nimport {mapPoints} from \"../internal/util\";\nimport {BlobOptions} from \"../public/blobs\";\nimport {Point} from \"./types\";\nimport {smooth} from \"./util\";\n\nexport const genBlob = (pointCount: number, offset: () => number): Point[] => {\n    const angle = (Math.PI * 2) / pointCount;\n\n    const points: Point[] = [];\n    for (let i = 0; i < pointCount; i++) {\n        const randPointOffset = offset();\n        const pointX = Math.sin(i * angle);\n        const pointY = Math.cos(i * angle);\n        points.push({\n            x: 0.5 + pointX * randPointOffset,\n            y: 0.5 + pointY * randPointOffset,\n            handleIn: {angle: 0, length: 0},\n            handleOut: {angle: 0, length: 0},\n        });\n    }\n\n    // https://math.stackexchange.com/a/873589/235756\n    const smoothingStrength = ((4 / 3) * Math.tan(angle / 4)) / Math.sin(angle / 2) / 2;\n\n    return smooth(points, smoothingStrength);\n};\n\nexport const genFromOptions = (blobOptions: BlobOptions): Point[] => {\n    const rgen = rand(String(blobOptions.seed));\n\n    // Scale of random movement increases as randomness approaches infinity.\n    // randomness = 0   -> rangeStart = 1\n    // randomness = 2   -> rangeStart = 0.8333\n    // randomness = 5   -> rangeStart = 0.6667\n    // randomness = 10  -> rangeStart = 0.5\n    // randomness = 20  -> rangeStart = 0.3333\n    // randomness = 50  -> rangeStart = 0.1667\n    // randomness = 100 -> rangeStart = 0.0909\n    const rangeStart = 1 / (1 + blobOptions.randomness / 10);\n\n    const points = genBlob(\n        3 + blobOptions.extraPoints,\n        () => (rangeStart + rgen() * (1 - rangeStart)) / 2,\n    );\n\n    const size = blobOptions.size;\n    return mapPoints(points, ({curr}) => {\n        curr.x *= size;\n        curr.y *= size;\n        curr.handleIn.length *= size;\n        curr.handleOut.length *= size;\n        return curr;\n    });\n};\n","// Seeded random number generator.\n// https://stackoverflow.com/a/47593316/3053361\nexport const rand = (seed: string) => {\n    const xfnv1a = (str: string) => {\n        let h = 2166136261 >>> 0;\n        for (let i = 0; i < str.length; i++) {\n            h = Math.imul(h ^ str.charCodeAt(i), 16777619);\n        }\n        return () => {\n            h += h << 13;\n            h ^= h >>> 7;\n            h += h << 3;\n            h ^= h >>> 17;\n            return (h += h << 5) >>> 0;\n        };\n    };\n\n    const sfc32 = (a: number, b: number, c: number, d: number) => () => {\n        a >>>= 0;\n        b >>>= 0;\n        c >>>= 0;\n        d >>>= 0;\n        var t = (a + b) | 0;\n        a = b ^ (b >>> 9);\n        b = (c + (c << 3)) | 0;\n        c = (c << 21) | (c >>> 11);\n        d = (d + 1) | 0;\n        t = (t + d) | 0;\n        c = (c + t) | 0;\n        return (t >>> 0) / 4294967296;\n    };\n\n    const seedGenerator = xfnv1a(seed);\n    return sfc32(seedGenerator(), seedGenerator(), seedGenerator(), seedGenerator());\n};\n","import {timingFunctions} from \"./animate/timing\";\n\nconst typeCheck = (name: string, val: any, expected: string[]) => {\n    let actual: string = typeof val;\n    if (actual === \"number\" && isNaN(val)) actual = \"NaN\";\n    if (actual === \"object\" && val === null) actual = \"null\";\n    if (!expected.includes(actual)) {\n        throw `\"${name}\" should have type \"${expected.join(\"|\")}\" but was \"${actual}\".`;\n    }\n};\n\nexport const checkKeyframeOptions = (keyframe: any) => {\n    typeCheck(`keyframe`, keyframe, [\"object\"]);\n    const {delay, duration, timingFunction, callback} = keyframe;\n    typeCheck(`delay`, delay, [\"number\", \"undefined\"]);\n    if (delay && delay < 0) throw `delay is invalid \"${delay}\".`;\n    typeCheck(`duration`, duration, [\"number\"]);\n    if (duration && duration < 0) throw `duration is invalid \"${duration}\".`;\n    typeCheck(`timingFunction`, timingFunction, [\"string\", \"undefined\"]);\n    if (timingFunction && !(timingFunctions as any)[timingFunction])\n        throw `\".timingFunction\" is not recognized \"${timingFunction}\".`;\n    typeCheck(`callback`, callback, [\"function\", \"undefined\"]);\n};\n\nexport const checkBlobOptions = (blobOptions: any) => {\n    typeCheck(`blobOptions`, blobOptions, [\"object\"]);\n    const {seed, extraPoints, randomness, size} = blobOptions;\n    typeCheck(`blobOptions.seed`, seed, [\"string\", \"number\"]);\n    typeCheck(`blobOptions.extraPoints`, extraPoints, [\"number\"]);\n    if (extraPoints < 0) throw `blobOptions.extraPoints is invalid \"${extraPoints}\".`;\n    typeCheck(`blobOptions.randomness`, randomness, [\"number\"]);\n    if (randomness < 0) throw `blobOptions.randomness is invalid \"${randomness}\".`;\n    typeCheck(`blobOptions.size`, size, [\"number\"]);\n    if (size < 0) throw `blobOptions.size is invalid \"${size}\".`;\n};\n\nexport const checkCanvasOptions = (canvasOptions: any) => {\n    typeCheck(`canvasOptions`, canvasOptions, [\"object\", \"undefined\"]);\n    if (canvasOptions) {\n        const {offsetX, offsetY} = canvasOptions;\n        typeCheck(`canvasOptions.offsetX`, offsetX, [\"number\", \"undefined\"]);\n        typeCheck(`canvasOptions.offsetY`, offsetY, [\"number\", \"undefined\"]);\n    }\n};\n\nexport const checkSvgOptions = (svgOptions: any) => {\n    typeCheck(`svgOptions`, svgOptions, [\"object\", \"undefined\"]);\n    if (svgOptions) {\n        const {fill, stroke, strokeWidth} = svgOptions;\n        typeCheck(`svgOptions.fill`, fill, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.stroke`, stroke, [\"string\", \"undefined\"]);\n        typeCheck(`svgOptions.strokeWidth`, strokeWidth, [\"number\", \"undefined\"]);\n    }\n};\n","import {genFromOptions} from \"../internal/gen\";\nimport {renderPath} from \"../internal/render/svg\";\nimport {renderPath2D} from \"../internal/render/canvas\";\nimport {mapPoints} from \"../internal/util\";\nimport {checkBlobOptions, checkCanvasOptions, checkSvgOptions} from \"../internal/check\";\n\nexport interface BlobOptions {\n    seed: string | number;\n    extraPoints: number;\n    randomness: number;\n    size: number;\n}\n\nexport interface CanvasOptions {\n    offsetX?: number;\n    offsetY?: number;\n}\n\nexport interface SvgOptions {\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n}\n\nexport const canvasPath = (blobOptions: BlobOptions, canvasOptions: CanvasOptions = {}): Path2D => {\n    try {\n        checkBlobOptions(blobOptions);\n        checkCanvasOptions(canvasOptions);\n    } catch (e) {\n        throw `(blobs2): ${e}`;\n    }\n    return renderPath2D(\n        mapPoints(genFromOptions(blobOptions), ({curr}) => {\n            curr.x += canvasOptions.offsetX || 0;\n            curr.y += canvasOptions.offsetY || 0;\n            return curr;\n        }),\n    );\n};\n\nexport const svg = (blobOptions: BlobOptions, svgOptions: SvgOptions = {}): string => {\n    try {\n        checkBlobOptions(blobOptions);\n        checkSvgOptions(svgOptions);\n    } catch (e) {\n        throw `(blobs2): ${e}`;\n    }\n    const path = svgPath(blobOptions);\n    const size = Math.floor(blobOptions.size);\n    const fill = svgOptions.fill === undefined ? \"#ec576b\" : svgOptions.fill;\n    const stroke = svgOptions.stroke === undefined ? \"none\" : svgOptions.stroke;\n    const strokeWidth = svgOptions.strokeWidth === undefined ? 0 : svgOptions.strokeWidth;\n    return `\n<svg width=\"${size}\" height=\"${size}\" viewBox=\"0 0 ${size} ${size}\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path stroke=\"${stroke}\" stroke-width=\"${strokeWidth}\" fill=\"${fill}\" d=\"${path}\"/>\n</svg>`.trim();\n};\n\nexport const svgPath = (blobOptions: BlobOptions): string => {\n    try {\n        checkBlobOptions(blobOptions);\n    } catch (e) {\n        throw `(blobs2): ${e}`;\n    }\n    return renderPath(genFromOptions(blobOptions));\n};\n","import {Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nexport interface RenderOptions {\n    // Viewport size.\n    width: number;\n    height: number;\n\n    // Transformation applied to all drawn points.\n    transform?: string;\n\n    // Declare whether the path should be closed.\n    // This option is currently always true.\n    closed: true;\n\n    // Output path styling.\n    fill?: string;\n    stroke?: string;\n    strokeWidth?: number;\n\n    // Option to render guides (points, handles and viewport).\n    guides?: boolean;\n    boundingBox?: boolean;\n}\n\nexport const renderPath = (points: Point[]): string => {\n    // Render path data attribute from points and handles.\n    let path = `M${points[0].x},${points[0].y}`;\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currControl = expandHandle(curr, curr.handleOut);\n        const nextControl = expandHandle(next, next.handleIn);\n        path += `C${currControl.x},${currControl.y},${nextControl.x},${nextControl.y},${next.x},${next.y}`;\n    });\n    return path;\n};\n\n// Renders the input points to an editable data structure which can be rendered to svg.\nexport const renderEditable = (points: Point[], options: RenderOptions): XmlElement => {\n    const stroke = options.stroke || (options.guides ? \"black\" : \"none\");\n    const strokeWidth = options.strokeWidth || (options.guides ? 1 : 0);\n\n    const xmlRoot = new XmlElement(\"svg\");\n    xmlRoot.attributes.width = options.width;\n    xmlRoot.attributes.height = options.height;\n    xmlRoot.attributes.viewBox = `0 0 ${options.width} ${options.height}`;\n    xmlRoot.attributes.xmlns = \"http://www.w3.org/2000/svg\";\n\n    const xmlContentGroup = new XmlElement(\"g\");\n    xmlContentGroup.attributes.transform = options.transform || \"\";\n\n    const xmlBlobPath = new XmlElement(\"path\");\n    xmlBlobPath.attributes.stroke = stroke;\n    xmlBlobPath.attributes[\"stroke-width\"] = strokeWidth;\n    xmlBlobPath.attributes.fill = options.fill || \"none\";\n    xmlBlobPath.attributes.d = renderPath(points);\n\n    xmlContentGroup.children.push(xmlBlobPath);\n    xmlRoot.children.push(xmlContentGroup);\n\n    // Render guides if configured to do so.\n    if (options.guides) {\n        const color = options.stroke || \"black\";\n        const size = options.strokeWidth || 1;\n\n        // Bounding box.\n        if (options.boundingBox) {\n            const xmlBoundingRect = new XmlElement(\"rect\");\n            xmlBoundingRect.attributes.x = 0;\n            xmlBoundingRect.attributes.y = 0;\n            xmlBoundingRect.attributes.width = options.width;\n            xmlBoundingRect.attributes.height = options.height;\n            xmlBoundingRect.attributes.fill = \"none\";\n            xmlBoundingRect.attributes.stroke = color;\n            xmlBoundingRect.attributes[\"stroke-width\"] = 2 * size;\n            xmlBoundingRect.attributes[\"stroke-dasharray\"] = 2 * size;\n            xmlContentGroup.children.push(xmlBoundingRect);\n        }\n\n        // Points and handles.\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n            const currControl = expandHandle(curr, curr.handleOut);\n            const nextControl = expandHandle(next, next.handleIn);\n\n            const xmlOutgoingHandleLine = new XmlElement(\"line\");\n            xmlOutgoingHandleLine.attributes.x1 = curr.x;\n            xmlOutgoingHandleLine.attributes.y1 = curr.y;\n            xmlOutgoingHandleLine.attributes.x2 = currControl.x;\n            xmlOutgoingHandleLine.attributes.y2 = currControl.y;\n            xmlOutgoingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlOutgoingHandleLine.attributes.stroke = color;\n\n            const xmlIncomingHandleLine = new XmlElement(\"line\");\n            xmlIncomingHandleLine.attributes.x1 = next.x;\n            xmlIncomingHandleLine.attributes.y1 = next.y;\n            xmlIncomingHandleLine.attributes.x2 = nextControl.x;\n            xmlIncomingHandleLine.attributes.y2 = nextControl.y;\n            xmlIncomingHandleLine.attributes[\"stroke-width\"] = size;\n            xmlIncomingHandleLine.attributes.stroke = color;\n            xmlIncomingHandleLine.attributes[\"stroke-dasharray\"] = 2 * size;\n\n            const xmlOutgoingHandleCircle = new XmlElement(\"circle\");\n            xmlOutgoingHandleCircle.attributes.cx = currControl.x;\n            xmlOutgoingHandleCircle.attributes.cy = currControl.y;\n            xmlOutgoingHandleCircle.attributes.r = size;\n            xmlOutgoingHandleCircle.attributes.fill = color;\n\n            const xmlIncomingHandleCircle = new XmlElement(\"circle\");\n            xmlIncomingHandleCircle.attributes.cx = nextControl.x;\n            xmlIncomingHandleCircle.attributes.cy = nextControl.y;\n            xmlIncomingHandleCircle.attributes.r = size;\n            xmlIncomingHandleCircle.attributes.fill = color;\n\n            const xmlPointCircle = new XmlElement(\"circle\");\n            xmlPointCircle.attributes.cx = curr.x;\n            xmlPointCircle.attributes.cy = curr.y;\n            xmlPointCircle.attributes.r = 2 * size;\n            xmlPointCircle.attributes.fill = color;\n\n            xmlContentGroup.children.push(xmlOutgoingHandleLine);\n            xmlContentGroup.children.push(xmlIncomingHandleLine);\n            xmlContentGroup.children.push(xmlOutgoingHandleCircle);\n            xmlContentGroup.children.push(xmlIncomingHandleCircle);\n            xmlContentGroup.children.push(xmlPointCircle);\n        });\n    }\n\n    return xmlRoot;\n};\n\n// Structured element with tag, attributes and children.\nexport class XmlElement {\n    public attributes: Record<string, string | number> = {};\n    public children: any[] = [];\n\n    public constructor(public tag: string) {}\n\n    public render(): string {\n        const attributes = this.renderAttributes();\n        const content = this.renderChildren();\n        if (content === \"\") {\n            return `<${this.tag}${attributes}/>`;\n        }\n        return `<${this.tag}${attributes}>${content}</${this.tag}>`;\n    }\n\n    private renderAttributes(): string {\n        const attributes = Object.keys(this.attributes);\n        if (attributes.length === 0) return \"\";\n        let out = \"\";\n        for (const attribute of attributes) {\n            out += ` ${attribute}=\"${this.attributes[attribute]}\"`;\n        }\n        return out;\n    }\n\n    private renderChildren(): string {\n        let out = \"\";\n        for (const child of this.children) {\n            out += child.render();\n        }\n        return out;\n    }\n}\n","import {Coord, Point} from \"../types\";\nimport {expandHandle, forPoints} from \"../util\";\n\nconst pointSize = 2;\nconst infoSpacing = 20;\n\nexport const clear = (ctx: CanvasRenderingContext2D) => {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n};\n\nexport const drawInfo = (ctx: CanvasRenderingContext2D, pos: number, label: string, value: any) => {\n    ctx.fillText(`${label}: ${value}`, infoSpacing, (pos + 1) * infoSpacing);\n};\n\nconst drawLine = (ctx: CanvasRenderingContext2D, a: Coord, b: Coord, style: string) => {\n    const backupStrokeStyle = ctx.strokeStyle;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    ctx.strokeStyle = style;\n    ctx.stroke();\n    ctx.strokeStyle = backupStrokeStyle;\n};\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, p: Coord, style: string) => {\n    const backupFillStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.arc(p.x, p.y, pointSize, 0, 2 * Math.PI);\n    ctx.fillStyle = style;\n    ctx.fill();\n    ctx.fillStyle = backupFillStyle;\n};\n\nexport const drawClosed = (ctx: CanvasRenderingContext2D, debug: boolean, points: Point[]) => {\n    if (points.length < 2) throw new Error(\"not enough points\");\n\n    // Draw debug points.\n    if (debug) {\n        forPoints(points, ({curr, next: getNext}) => {\n            const next = getNext();\n\n            // Compute coordinates of handles.\n            const currHandle = expandHandle(curr, curr.handleOut);\n            const nextHandle = expandHandle(next, next.handleIn);\n\n            drawPoint(ctx, curr, \"\");\n            drawLine(ctx, curr, currHandle, \"#ccc\");\n            drawLine(ctx, next, nextHandle, \"#b6b\");\n        });\n    }\n\n    ctx.stroke(renderPath2D(points));\n};\n\nexport const renderPath2D = (points: Point[]): Path2D => {\n    const path = new Path2D();\n\n    if (points.length < 1) return path;\n    path.moveTo(points[0].x, points[0].y);\n\n    forPoints(points, ({curr, next: getNext}) => {\n        const next = getNext();\n        const currHandle = expandHandle(curr, curr.handleOut);\n        const nextHandle = expandHandle(next, next.handleIn);\n        path.bezierCurveTo(currHandle.x, currHandle.y, nextHandle.x, nextHandle.y, next.x, next.y);\n    });\n\n    return path;\n};\n"],"names":["copyPoint","p","x","y","handleIn","handleOut","forPoints","points","callback","i","sibling","pos","mod","length","curr","index","prev","next","mapPoints","out","args","push","expandHandle","point","handle","Math","cos","angle","sin","smooth","strength","_a","a","b","dx","dy","atan2","abs","PI","distance","genFromOptions","blobOptions","c","d","rgen","seedGenerator","str","h","imul","charCodeAt","xfnv1a","seed","String","t","rangeStart","randomness","pointCount","offset","randPointOffset","pointX","pointY","smoothingStrength","tan","genBlob","extraPoints","size","typeCheck","name","val","expected","actual","isNaN","includes","join","checkBlobOptions","n","sqrt","svgPath","e","path","getNext","currControl","nextControl","canvasOptions","offsetX","offsetY","Path2D","moveTo","currHandle","nextHandle","bezierCurveTo","svgOptions","fill","stroke","strokeWidth","floor","undefined","trim"],"mappings":"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"}